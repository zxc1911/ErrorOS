## 2.6 中断使能与屏蔽

#### 配置 sie 寄存器（中断使能）

`sie`（Supervisor Interrupt Enable）寄存器控制哪些中断类型被使能。

**sie 寄存器的结构**

```
 63  ...  9   8  ...  5   4  ...  1   0
┌────...────┬──────...────┬──────...────┐
│    ...    │SEIE│ ... │STIE│ ... │SSIE│
└────...────┴──────...────┴──────...────┘

SSIE (bit 1): Supervisor Software Interrupt Enable
STIE (bit 5): Supervisor Timer Interrupt Enable
SEIE (bit 9): Supervisor External Interrupt Enable
```

**操作 sie 寄存器**

在 `interrupts.rs` 中添加：

```rust
/// 启用定时器中断
pub fn enable_timer_interrupt() {
    unsafe {
        riscv::register::sie::set_stimer();
    }
    serial_println!("[INTERRUPT] Timer interrupt enabled");
}

/// 禁用定时器中断
pub fn disable_timer_interrupt() {
    unsafe {
        riscv::register::sie::clear_stimer();
    }
    serial_println!("[INTERRUPT] Timer interrupt disabled");
}

/// 启用外部中断
pub fn enable_external_interrupt() {
    unsafe {
        riscv::register::sie::set_sext();
    }
    serial_println!("[INTERRUPT] External interrupt enabled");
}
```

---

#### 配置 sip 寄存器（中断挂起）

`sip`（Supervisor Interrupt Pending）寄存器显示哪些中断正在挂起（等待处理）。

**sip 寄存器的结构**

```
 63  ...  9   8  ...  5   4  ...  1   0
┌────...────┬──────...────┬──────...────┐
│    ...    │SEIP│ ... │STIP│ ...  │SSIP│
└────...────┴──────...────┴──────...────┘

SSIP (bit 1): Supervisor Software Interrupt Pending
STIP (bit 5): Supervisor Timer Interrupt Pending
SEIP (bit 9): Supervisor External Interrupt Pending
```

**触发软件中断**

```rust
/// 触发软件中断
pub fn trigger_software_interrupt() {
    unsafe {
        riscv::register::sip::set_ssoft();
    }
}

/// 清除软件中断
pub fn clear_software_interrupt() {
    unsafe {
        riscv::register::sip::clear_ssoft();
    }
}
```

---

#### 全局中断开关

**启用/禁用全局中断**

在 `interrupts.rs` 中添加：

```rust
/// 启用全局中断
///
/// # 功能
/// 设置 sstatus.SIE = 1
pub fn enable_interrupts() {
    unsafe {
        sstatus::set_sie();
    }
    serial_println!("[INTERRUPT] Global interrupts enabled");
}

/// 禁用全局中断
///
/// # 功能
/// 设置 sstatus.SIE = 0
pub fn disable_interrupts() {
    unsafe {
        sstatus::clear_sie();
    }
    serial_println!("[INTERRUPT] Global interrupts disabled");
}

/// 在禁用中断的情况下执行闭包
///
/// # 用途
/// 实现临界区保护
pub fn without_interrupts<F, R>(f: F) -> R
where
    F: FnOnce() -> R,
{
    let sie = sstatus::read().sie();

    if sie {
        unsafe { sstatus::clear_sie(); }
    }

    let ret = f();

    if sie {
        unsafe { sstatus::set_sie(); }
    }

    ret
}
```

---

**实现定时器中断**

在 `interrupts.rs` 中添加定时器相关函数：

```rust
/// 定时器中断处理
fn timer_interrupt_handler() {
    // 设置下一次定时器中断
    set_next_timer();
}

/// 设置下一次定时器中断
fn set_next_timer() {
    const TIMER_INTERVAL: u64 = 1_000_000; // 100ms @ 10MHz

    let time = riscv::register::time::read64();
    sbi_set_timer(time + TIMER_INTERVAL);
}

/// SBI 调用：设置定时器
fn sbi_set_timer(stime_value: u64) {
    unsafe {
        core::arch::asm!(
            "mv a0, {0}",
            "li a7, 0",
            "ecall",
            in(reg) stime_value,
            out("a0") _,
            out("a1") _,
            options(nostack)
        );
    }
}

/// 外部中断处理
fn external_interrupt_handler() {
    serial_println!("[INTERRUPT] External interrupt");
}

/// 软件中断处理
fn software_interrupt_handler() {
    serial_println!("[INTERRUPT] Software interrupt");
    // 清除软件中断标志
    clear_software_interrupt();
}
```

---

**完善初始化函数**

修改 `init_idt()` 函数：

```rust
/// 初始化中断描述符表
pub fn init_idt() {
    serial_println!("[INTERRUPT] Initializing IDT...");

    // 1. 设置 stvec
    unsafe {
        stvec::write(trap_entry as usize, stvec::TrapMode::Direct);
    }
    serial_println!("[INTERRUPT] stvec set to {:#x}", trap_entry as usize);

    // 2. 启用定时器中断
    enable_timer_interrupt();

    // 3. 设置第一个定时器中断
    set_next_timer();

    serial_println!("[INTERRUPT] IDT initialized");
}
```
