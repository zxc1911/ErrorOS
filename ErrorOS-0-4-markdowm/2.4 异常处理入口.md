## 2.4 异常处理入口

这一节是本章的核心，我们需要用汇编保存和恢复寄存器上下文。

#### 保存所有通用寄存器

**为什么需要保存寄存器？**

当陷阱发生时，我们的处理程序会使用寄存器。如果不保存，就会破坏原程序的数据：

```
程序正在执行：
  x1 = 100
  x2 = 200
  x3 = x1 + x2  ← 期望 x3 = 300

陷阱发生，进入处理程序：
  x1 = 123  ← 处理程序修改了 x1
  x2 = 456  ← 处理程序修改了 x2

返回后：
  x3 = x1 + x2  ← 得到 579，错误！
```

**因此我们需要保存所有寄存器**，陷阱发生时，先保存所有寄存器到栈，然后执行处理程序，再恢复所有寄存器从栈，这样原程序看不到任何变化。

---

**RISC-V 的寄存器**

RISC-V 有 32 个通用寄存器（x0-x31）：

```
x0:  zero - 硬连线为 0
x1:  ra   - 返回地址
x2:  sp   - 栈指针
x3:  gp   - 全局指针
x4:  tp   - 线程指针
x5:  t0   - 临时寄存器 0
x6:  t1   - 临时寄存器 1
x7:  t2   - 临时寄存器 2
x8:  s0/fp- 保存寄存器 0 / 帧指针
x9:  s1   - 保存寄存器 1
x10: a0   - 函数参数 0 / 返回值 0
x11: a1   - 函数参数 1 / 返回值 1
x12: a2   - 函数参数 2
x13: a3   - 函数参数 3
x14: a4   - 函数参数 4
x15: a5   - 函数参数 5
x16: a6   - 函数参数 6
x17: a7   - 函数参数 7
x18: s2   - 保存寄存器 2
...
x27: s11  - 保存寄存器 11
x28: t3   - 临时寄存器 3
x29: t4   - 临时寄存器 4
x30: t5   - 临时寄存器 5
x31: t6   - 临时寄存器 6
```

---

**定义 TrapContext 结构体**

首先在 `interrupts.rs` 中定义陷阱上下文结构：

```rust
/// 陷阱上下文
///
/// # 说明
/// 保存所有通用寄存器的值
/// 陷阱发生时保存，返回时恢复
#[repr(C)]
pub struct TrapContext {
    pub x: [usize; 32],     // x0-x31
    pub sstatus: usize,     // sstatus CSR
    pub sepc: usize,        // sepc CSR
}

impl TrapContext {
    /// 创建一个新的陷阱上下文
    pub fn new() -> Self {
        Self {
            x: [0; 32],
            sstatus: 0,
            sepc: 0,
        }
    }
}
```

**为什么是 `#[repr(C)]`？**

`#[repr(C)]` 告诉编译器按 C 语言的方式布局结构体（字段按顺序排列，无优化），这样我们在汇编中可以用固定的偏移访问字段。

---

**编写汇编入口**

在 `interrupts.rs` 中添加：

```rust
use core::arch::global_asm;

// 嵌入汇编代码
global_asm!(include_str!("trap.S"));

// 声明汇编中定义的符号
extern "C" {
    fn trap_entry();
}
```

**创建 trap.S 文件**

```bash
cd os/src
touch trap.S
```

编辑 `os/src/trap.S`：

```assembly
# ============================================
# 陷阱处理入口（汇编）
# ============================================
# 功能：
# 1. 保存所有寄存器到栈
# 2. 调用 Rust 的陷阱处理函数
# 3. 恢复所有寄存器
# 4. 返回
# ============================================

.section .text
.globl trap_entry
.align 4

trap_entry:
    # ============================================
    # 第1步：在栈上分配空间
    # ============================================
    # TrapContext 大小 = 32 * 8 + 2 * 8 = 272 字节
    # 对齐到 16 字节：272 → 272
    addi sp, sp, -272

    # ============================================
    # 第2步：保存所有通用寄存器
    # ============================================
    # 注意：x0 (zero) 始终为 0，不需要保存
    # 但为了简化代码，我们仍然保存它

    sd x1,  8(sp)    # ra
    # 注意：x2 (sp) 需要特殊处理，稍后保存
    sd x3,  24(sp)   # gp
    sd x4,  32(sp)   # tp
    sd x5,  40(sp)   # t0
    sd x6,  48(sp)   # t1
    sd x7,  56(sp)   # t2
    sd x8,  64(sp)   # s0/fp
    sd x9,  72(sp)   # s1
    sd x10, 80(sp)   # a0
    sd x11, 88(sp)   # a1
    sd x12, 96(sp)   # a2
    sd x13, 104(sp)  # a3
    sd x14, 112(sp)  # a4
    sd x15, 120(sp)  # a5
    sd x16, 128(sp)  # a6
    sd x17, 136(sp)  # a7
    sd x18, 144(sp)  # s2
    sd x19, 152(sp)  # s3
    sd x20, 160(sp)  # s4
    sd x21, 168(sp)  # s5
    sd x22, 176(sp)  # s6
    sd x23, 184(sp)  # s7
    sd x24, 192(sp)  # s8
    sd x25, 200(sp)  # s9
    sd x26, 208(sp)  # s10
    sd x27, 216(sp)  # s11
    sd x28, 224(sp)  # t3
    sd x29, 232(sp)  # t4
    sd x30, 240(sp)  # t5
    sd x31, 248(sp)  # t6

    # 保存原来的 sp（陷阱发生前的栈指针）
    addi t0, sp, 272     # t0 = 原来的 sp
    sd t0, 16(sp)        # 保存到 x[2]

    # ============================================
    # 第3步：保存 CSR 寄存器
    # ============================================
    csrr t0, sstatus
    sd t0, 256(sp)       # 偏移 256 = 32 * 8

    csrr t1, sepc
    sd t1, 264(sp)       # 偏移 264 = 33 * 8

    # ============================================
    # 第4步：调用 Rust 处理函数
    # ============================================
    # 参数传递：a0 = &TrapContext
    mv a0, sp            # a0 = sp (指向 TrapContext)

    call trap_handler    # 调用 Rust 函数

    # ============================================
    # 第5步：恢复 CSR 寄存器
    # ============================================
    ld t0, 256(sp)
    csrw sstatus, t0

    ld t1, 264(sp)
    csrw sepc, t1

    # ============================================
    # 第6步：恢复通用寄存器
    # ============================================
    ld x1,  8(sp)
    ld x3,  24(sp)
    ld x4,  32(sp)
    ld x5,  40(sp)
    ld x6,  48(sp)
    ld x7,  56(sp)
    ld x8,  64(sp)
    ld x9,  72(sp)
    ld x10, 80(sp)
    ld x11, 88(sp)
    ld x12, 96(sp)
    ld x13, 104(sp)
    ld x14, 112(sp)
    ld x15, 120(sp)
    ld x16, 128(sp)
    ld x17, 136(sp)
    ld x18, 144(sp)
    ld x19, 152(sp)
    ld x20, 160(sp)
    ld x21, 168(sp)
    ld x22, 176(sp)
    ld x23, 184(sp)
    ld x24, 192(sp)
    ld x25, 200(sp)
    ld x26, 208(sp)
    ld x27, 216(sp)
    ld x28, 224(sp)
    ld x29, 232(sp)
    ld x30, 240(sp)
    ld x31, 248(sp)

    # 最后恢复 sp
    ld x2,  16(sp)

    # ============================================
    # 第7步：返回
    # ============================================
    sret                 # 从陷阱返回
```

**汇编代码详解**

1. **分配栈空间**：

   ```assembly
   addi sp, sp, -272
   ```

   在栈上分配 272 字节用于存储 TrapContext。

2. **保存寄存器**：

   ```assembly
   sd x1, 8(sp)   # 保存 x1 到 sp+8
   ```

   使用 `sd`（store doubleword）指令保存 64 位寄存器。

3. **特殊处理 sp**：

   ```assembly
   addi t0, sp, 272   # 计算原来的 sp
   sd t0, 16(sp)      # 保存
   ```

   因为 sp 已经被修改了，所以需要计算原值。

4. **保存 CSR**：

   ```assembly
   csrr t0, sstatus   # 读取 sstatus 到 t0
   sd t0, 256(sp)     # 保存到栈
   ```

5. **调用 Rust 函数**：

   ```assembly
   mv a0, sp          # 第一个参数 = TrapContext 的地址
   call trap_handler  # 调用
   ```

6. **恢复寄存器和返回**：
   先恢复 CSR，再恢复通用寄存器，最后 `sret`。

---

#### 保存浮点寄存器（可选）

RISC-V 有 32 个浮点寄存器（f0-f31）。如果你的程序使用了浮点运算，需要保存它们。

**我们的选择：暂不保存**

原因：

1. 我们的内核目前不使用浮点运算
2. 保存浮点寄存器需要额外的 256 字节（32 × 8）
3. 会增加上下文切换的开销

**如果需要支持浮点，可以这样做**：

```assembly
# 在 TrapContext 中添加浮点寄存器字段
# 然后在保存通用寄存器后：

fsd f0,  272(sp)
fsd f1,  280(sp)
fsd f2,  288(sp)
# ... 继续保存 f3-f31
```

---

#### 调用 Rust 异常处理函数

现在我们实现 Rust 的陷阱处理函数。在 `interrupts.rs` 中添加：

```rust
/// Rust 陷阱处理函数
///
/// # 参数
/// - `ctx`: 陷阱上下文的可变引用
///
/// # 说明
/// 从汇编入口调用，参数 a0 = &mut TrapContext
#[no_mangle]
pub extern "C" fn trap_handler(ctx: &mut TrapContext) {
    // 读取 CSR 寄存器
    let scause = scause::read();
    let stval = stval::read();

    // 注意：sepc 已经保存在 ctx.sepc 中
    let sepc = ctx.sepc;

    // 调用陷阱分发器
    trap_dispatcher(ctx, scause, stval, sepc);
}
```

**为什么需要 `#[no_mangle]`？**

因为汇编代码中使用了 `call trap_handler`，需要保证函数名不被 Rust 编译器修改（name mangling）。

---

#### 恢复寄存器上下文

恢复寄存器的代码已经在 `trap.S` 的第6步实现了。

**关键点**：

1. 先恢复 CSR 寄存器（sstatus、sepc）
2. 再恢复通用寄存器
3. 最后恢复 sp

**为什么这个顺序？**

```
如果先恢复 sp：
  ld sp, 16(sp)      # sp 被修改了
  ld t0, 256(sp)     # 错误！现在 sp 指向错误的位置

正确顺序：
  ld t0, 256(sp)     # 使用原来的 sp 读取
  csrw sstatus, t0
  ...
  ld sp, 16(sp)      # 最后恢复 sp
```

---

#### 使用 sret 返回

`sret` 指令（Supervisor Return）用于从陷阱返回：

**sret 做了什么？**

```
执行 sret 时，硬件自动：

1. PC ← sepc
   跳转回触发陷阱的地方

2. 特权级 ← sstatus.SPP
   恢复之前的特权级（U-mode 或 S-mode）

3. sstatus.SIE ← sstatus.SPIE
   恢复中断使能状态

4. sstatus.SPP ← 0 (U-mode)
   为下次陷阱做准备
```

**重要**：`sret` 是特权指令，只能在 S-mode 或更高级别执行。