## 0.3 项目结构初始化

#### 创建 Cargo 工作空间

**步骤 1：创建项目目录**

```bash
mkdir -p ErrorOS
cd ErrorOS
```

**步骤 2：初始化 Cargo 项目**

```bash
cargo new os --bin
cd os
```

**步骤 3：创建项目结构**

```bash
mkdir -p .cargo
mkdir -p src
mkdir -p docs
```

最终项目结构：

```
ErrorOS/
├── os/                         # 内核代码目录
│   ├── .cargo/
│   │   └── config.toml         # Cargo 配置
│   ├── src/
│   │   ├── main.rs             # 内核主程序
│   │   ├── lib.rs              # 库入口
│   │   └── ...                 # 其他模块
│   ├── Cargo.toml              # 项目配置
│   └── linker-riscv64.ld       # 链接器脚本
├── docs/                       # 文档目录
├── run.sh                      # QEMU 运行脚本
└── README.md                   # 项目说明
```

---

#### 配置编译目标

**步骤 1：创建 `.cargo/config.toml`**

在 `os/.cargo/` 目录创建 `config.toml` 文件：

```toml
# ============================================
# RISC-V 64 构建配置
# ============================================

[build]
# 使用内置的 RISC-V 64 目标
target = "riscv64imac-unknown-none-elf"

[toolchain]
# 需要 nightly 版本的 Rust
channel = "nightly"

[unstable]
# 从源代码构建标准库组件
build-std = ["core", "compiler_builtins", "alloc"]
build-std-features = ["compiler-builtins-mem"]

# ============================================
# RISC-V 目标配置
# ============================================

[target.riscv64imac-unknown-none-elf]
# 指定链接脚本
rustflags = ["-C", "link-arg=-Tlinker-riscv64.ld"]

# ============================================
# QEMU 运行配置
# ============================================

[target.'cfg(target_arch = "riscv64")']
# RISC-V QEMU 运行器
runner = """qemu-system-riscv64 \
    -machine virt \
    -cpu rv64 \
    -smp 1 \
    -m 128M \
    -bios default \
    -serial stdio \
    -display default \
    -kernel"""
```

**配置说明**

- `build-std`: 从源代码构建 `core`、`compiler_builtins`、`alloc` 库
- `build-std-features`: 启用 `compiler-builtins-mem` 特性（提供 memcpy 等函数）
- `rustflags`: 传递给 rustc 的额外标志
- `runner`: cargo run 时自动使用的运行器

---

**步骤 2：配置 `Cargo.toml`**

编辑 `os/Cargo.toml`：

```toml
[package]
name = "os"
version = "0.1.0"
edition = "2021"
authors = ["Your Name <your.email@example.com>"]

[profile.dev]
panic = "abort"         # panic 时直接终止，不展开栈

[profile.release]
panic = "abort"

# ============================================
# RISC-V 64 依赖配置
# ============================================

[dependencies]
# 基础依赖
volatile = "0.2.6"              # Volatile 读写操作
spin = "0.5.2"                  # 自旋锁
uart_16550 = "0.3.0"            # UART 16550 串口驱动
linked_list_allocator = "0.10.5" # 堆分配器
bitflags = "2.6"                # 位标志

# RISC-V 特定依赖
riscv = "0.11"                  # RISC-V 架构支持

[dependencies.lazy_static]
version = "1.0"
features = ["spin_no_std"]

[dependencies.crossbeam-queue]
version = "0.3.11"
default-features = false
features = ["alloc"]

[dependencies.conquer-once]
version = "0.2.0"
default-features = false

[dependencies.futures-util]
version = "0.3.4"
default-features = false
features = ["alloc"]
```

---

#### 编写链接器脚本

**步骤 1：创建链接器脚本**

在 `os/` 目录创建 `linker-riscv64.ld`：

```ld
/* ============================================
 * RISC-V 64 操作系统链接脚本
 * ============================================
 * 功能：定义内核的内存布局和段分配
 * 目标：QEMU virt 机器
 * 基地址：0x80200000（在 OpenSBI 之后加载）
 * 注意：OpenSBI 加载在 0x80000000，占用约 256KB
 */

OUTPUT_ARCH(riscv)
ENTRY(_start)

/* 内存布局配置 */
BASE_ADDRESS = 0x80200000;

SECTIONS
{
    /* 内核加载到 0x80200000（OpenSBI 之后） */
    . = BASE_ADDRESS;

    kernel_start = .;

    /* ============================================
     * .text 段：代码段
     * ============================================ */
    .text : ALIGN(4K) {
        *(.text.entry)      /* 入口代码（_start 函数） */
        *(.text .text.*)    /* 所有代码 */
    }

    /* ============================================
     * .rodata 段：只读数据段
     * ============================================ */
    .rodata : ALIGN(4K) {
        *(.rodata .rodata.*)    /* 只读数据 */
        *(.srodata .srodata.*)  /* 小段只读数据 */
    }

    /* ============================================
     * .data 段：已初始化数据段
     * ============================================ */
    .data : ALIGN(4K) {
        *(.data .data.*)        /* 全局变量 */
        *(.sdata .sdata.*)      /* 小段数据 */
    }

    /* ============================================
     * .bss 段：未初始化数据段
     * ============================================ */
    .bss : ALIGN(4K) {
        bss_start = .;
        *(.bss .bss.*)
        *(.sbss .sbss.*)
        bss_end = .;
    }

    /* ============================================
     * 堆和栈区域
     * ============================================ */
    .heap : ALIGN(4K) {
        heap_start = .;
        . += 1024K;  /* 1 MB 堆空间 */
        heap_end = .;
    }

    .stack : ALIGN(4K) {
        stack_start = .;
        . += 512K;   /* 512 KB 栈空间 */
        stack_end = .;
    }

    kernel_end = .;

    /* ============================================
     * 丢弃不需要的段
     * ============================================ */
    /DISCARD/ : {
        *(.eh_frame)        /* 异常处理帧 */
        *(.comment)         /* 注释信息 */
    }
}
```

