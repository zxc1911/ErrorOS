

## 3.2 物理地址抽象

在 C 语言中，地址通常就是一个 `usize` 或 `void*`，但这样无法区分物理地址和虚拟地址。

但如果像以下这样写：

```rust
let phys_addr = PhysAddr::new(0x80200000);
let page = phys_addr.page_number();
let aligned = phys_addr.align_down(4096);
```

编译器会检查类型，数据类型较为安全；且封装的较好，隐藏实现细节。


#### 实现 PhysAddr 类型

**定义 PhysAddr 结构体**

在 `os/src/memory.rs` 中添加：

```rust
/// 物理地址类型
///
/// # 设计
/// - 使用 newtype 模式封装 usize
/// - 提供类型安全的地址操作
/// - 自动进行对齐检查
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PhysAddr(usize);

impl PhysAddr {
    /// 创建新的物理地址
    ///
    /// # 参数
    /// - `addr`: 物理地址值
    ///
    /// # 返回
    /// PhysAddr 实例
    pub const fn new(addr: usize) -> Self {
        Self(addr)
    }

    /// 获取地址值
    pub const fn as_usize(&self) -> usize {
        self.0
    }

    /// 对齐到向下取整（向下对齐）
    ///
    /// # 参数
    /// - `align`: 对齐边界（必须是 2 的幂）
    ///
    /// # 示例
    /// ```
    /// let addr = PhysAddr::new(0x8020_1234);
    /// let aligned = addr.align_down(4096);  // 0x8020_1000
    /// ```
    pub const fn align_down(&self, align: usize) -> Self {
        Self(self.0 & !(align - 1))
    }

    /// 对齐到向上取整（向上对齐）
    ///
    /// # 参数
    /// - `align`: 对齐边界（必须是 2 的幂）
    ///
    /// # 示例
    /// ```
    /// let addr = PhysAddr::new(0x8020_1234);
    /// let aligned = addr.align_up(4096);  // 0x8020_2000
    /// ```
    pub const fn align_up(&self, align: usize) -> Self {
        Self((self.0 + align - 1) & !(align - 1))
    }

    /// 检查地址是否按指定边界对齐
    ///
    /// # 参数
    /// - `align`: 对齐边界
    ///
    /// # 返回
    /// true 表示已对齐，false 表示未对齐
    pub const fn is_aligned(&self, align: usize) -> bool {
        self.0 % align == 0
    }

    /// 计算页号（假设页大小为 4KB）
    ///
    /// # 返回
    /// 页号（物理地址 / 4096）
    pub const fn page_number(&self) -> usize {
        self.0 / PAGE_SIZE
    }

    /// 计算页内偏移
    ///
    /// # 返回
    /// 页内偏移（物理地址 % 4096）
    pub const fn page_offset(&self) -> usize {
        self.0 % PAGE_SIZE
    }
}
```

**实现 Debug 和 Display trait**

为了方便调试和打印，我们实现这两个 trait：

```rust
use core::fmt;

impl fmt::Debug for PhysAddr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "PhysAddr({:#x})", self.0)
    }
}

impl fmt::Display for PhysAddr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:#x}", self.0)
    }
}
```

**实现算术运算**

为了支持地址的加减运算，我们实现 `Add` 和 `Sub` trait：

```rust
use core::ops::{Add, Sub};

impl Add<usize> for PhysAddr {
    type Output = Self;

    fn add(self, offset: usize) -> Self {
        Self(self.0 + offset)
    }
}

impl Sub<usize> for PhysAddr {
    type Output = Self;

    fn sub(self, offset: usize) -> Self {
        Self(self.0 - offset)
    }
}

impl Sub<PhysAddr> for PhysAddr {
    type Output = usize;

    fn sub(self, other: PhysAddr) -> usize {
        self.0 - other.0
    }
}
```

---

#### 测试 PhysAddr

**创建测试函数**

在 `os/src/memory.rs` 中添加：

```rust
/// 测试物理地址抽象
pub fn test_phys_addr() {
    use crate::println;

    println!("\n========================================");
    println!("  测试 PhysAddr");
    println!("========================================\n");

    // 测试 1：创建地址
    let addr = PhysAddr::new(0x8020_1234);
    println!("[TEST 1] 创建地址");
    println!("  地址: {:?}", addr);
    println!("  值: {:#x}", addr.as_usize());

    // 测试 2：对齐
    println!("\n[TEST 2] 对齐操作");
    println!("  原地址:      {}", addr);
    println!("  向下对齐 4K: {}", addr.align_down(PAGE_SIZE));
    println!("  向上对齐 4K: {}", addr.align_up(PAGE_SIZE));
    println!("  是否 4K 对齐: {}", addr.is_aligned(PAGE_SIZE));

    let aligned_addr = PhysAddr::new(0x8020_1000);
    println!("  对齐地址:    {}", aligned_addr);
    println!("  是否 4K 对齐: {}", aligned_addr.is_aligned(PAGE_SIZE));

    // 测试 3：页号和偏移
    println!("\n[TEST 3] 页号和偏移");
    println!("  地址: {}", addr);
    println!("  页号: {}", addr.page_number());
    println!("  页内偏移: {:#x}", addr.page_offset());

    // 测试 4：算术运算
    println!("\n[TEST 4] 算术运算");
    let addr1 = PhysAddr::new(0x8020_0000);
    let addr2 = addr1 + 0x1000;
    println!("  地址1: {}", addr1);
    println!("  地址2 (地址1 + 4KB): {}", addr2);
    println!("  差值: {:#x} bytes", addr2 - addr1);

    println!("\n========================================\n");
}
```

**在 main.rs 中调用测试**

编辑 `os/src/main.rs`：

```rust
#[no_mangle]
pub extern "C" fn kernel_main() -> ! {
    println!("Welcome to Error OS!");
    os::init();

    // 打印内存布局
    os::memory::print_memory_layout();

    // 测试物理地址
    os::memory::test_phys_addr();

    // ... 其他代码 ...

    os::hlt_loop();
}
```

**编译并运行**

```bash
cargo build --release
# 运行 QEMU（命令同前）
```

**预期输出**

```
========================================
  测试 PhysAddr
========================================

[TEST 1] 创建地址
  地址: PhysAddr(0x80201234)
  值: 0x80201234

[TEST 2] 对齐操作
  原地址:      0x80201234
  向下对齐 4K: 0x80201000
  向上对齐 4K: 0x80202000
  是否 4K 对齐: false
  对齐地址:    0x80201000
  是否 4K 对齐: true

[TEST 3] 页号和偏移
  地址: 0x80201234
  页号: 524801
  页内偏移: 0x234

[TEST 4] 算术运算
  地址1: 0x80200000
  地址2 (地址1 + 4KB): 0x80201000
  差值: 0x1000 bytes

========================================
```

看到这样的输出说明 PhysAddr 实现正确！

---

#### 实现 VirtAddr 类型

虽然在本章我们主要处理物理内存，但为了完整性，我们也实现虚拟地址类型。它的实现与 PhysAddr 非常相似。

**在 memory.rs 中添加**

```rust
/// 虚拟地址类型
///
/// # 说明
/// 在第4章（虚拟内存）中会详细使用
/// 现在先定义好接口
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct VirtAddr(usize);

impl VirtAddr {
    pub const fn new(addr: usize) -> Self {
        Self(addr)
    }

    pub const fn as_usize(&self) -> usize {
        self.0
    }

    pub const fn align_down(&self, align: usize) -> Self {
        Self(self.0 & !(align - 1))
    }

    pub const fn align_up(&self, align: usize) -> Self {
        Self((self.0 + align - 1) & !(align - 1))
    }

    pub const fn is_aligned(&self, align: usize) -> bool {
        self.0 % align == 0
    }

    pub const fn page_number(&self) -> usize {
        self.0 / PAGE_SIZE
    }

    pub const fn page_offset(&self) -> usize {
        self.0 % PAGE_SIZE
    }
}

impl fmt::Debug for VirtAddr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "VirtAddr({:#x})", self.0)
    }
}

impl fmt::Display for VirtAddr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:#x}", self.0)
    }
}

impl Add<usize> for VirtAddr {
    type Output = Self;
    fn add(self, offset: usize) -> Self {
        Self(self.0 + offset)
    }
}

impl Sub<usize> for VirtAddr {
    type Output = Self;
    fn sub(self, offset: usize) -> Self {
        Self(self.0 - offset)
    }
}

impl Sub<VirtAddr> for VirtAddr {
    type Output = usize;
    fn sub(self, other: VirtAddr) -> usize {
        self.0 - other.0
    }
}
```
