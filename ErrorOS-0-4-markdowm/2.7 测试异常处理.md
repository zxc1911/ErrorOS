## 2.7 测试异常处理

#### 测试断点异常

**修改 lib.rs**

在 `os/src/lib.rs` 中添加初始化函数：

```rust
/// 初始化操作系统
pub fn init() {
    serial_println!("[INIT] Initializing OS...");

    // 初始化中断系统
    interrupts::init_idt();

    // 启用全局中断
    interrupts::enable_interrupts();

    serial_println!("[INIT] OS initialized");
}

/// 无限循环（使用 wfi）
pub fn hlt_loop() -> ! {
    loop {
        riscv::asm::wfi();
    }
}
```

**步骤 2：修改 main.rs**

编辑 `os/src/main.rs`：

```rust
#![no_std]
#![no_main]

use core::arch::global_asm;
use core::panic::PanicInfo;
use os::println;

// 汇编入口（保持不变）
global_asm!(
    ".section .text.entry",
    ".globl _start",
    "_start:",
    "   la sp, stack_end",
    "   la t0, bss_start",
    "   la t1, bss_end",
    "1:",
    "   bgeu t0, t1, 2f",
    "   sd zero, (t0)",
    "   addi t0, t0, 8",
    "   j 1b",
    "2:",
    "   call kernel_main",
    "3:",
    "   wfi",
    "   j 3b",
);

#[cfg(not(test))]
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    println!("{}", info);
    os::hlt_loop();
}

#[no_mangle]
pub extern "C" fn kernel_main() -> ! {
    println!("Welcome to Error OS!");
    println!("========================================");

    // 初始化系统
    os::init();

    println!("\n========================================");
    println!("  测试断点异常");
    println!("========================================\n");

    // 测试断点异常
    println!("触发断点异常...");
    unsafe {
        core::arch::asm!("ebreak");
    }
    println!("断点异常处理成功！\n");

    println!("系统进入等待状态，按 Ctrl+A 然后 X 退出 QEMU\n");

    os::hlt_loop();
}
```

**步骤 3：编译并运行**

```bash
cd os
cargo build --release

# 运行 QEMU
qemu-system-riscv64 \
    -machine virt \
    -cpu rv64 \
    -smp 1 \
    -m 128M \
    -bios default \
    -nographic \
    -serial stdio \
    -kernel target/riscv64imac-unknown-none-elf/release/os
```

**预期输出**

```
Welcome to Error OS!
========================================
[INIT] Initializing OS...
[INTERRUPT] Initializing IDT...
[INTERRUPT] stvec set to 0x80xxxxxx
[INTERRUPT] Timer interrupt enabled
[INTERRUPT] IDT initialized
[INTERRUPT] Global interrupts enabled
[INIT] OS initialized

========================================
  测试断点异常
========================================

触发断点异常...
[EXCEPTION] Breakpoint at 0x80xxxxxx
EXCEPTION: BREAKPOINT at 0x80xxxxxx
断点异常处理成功！

系统进入等待状态，按 Ctrl+A 然后 X 退出 QEMU
```

如果看到 "断点异常处理成功！"，说明异常处理正常工作。

---

#### 测试非法指令异常

我们可以通过内联汇编触发非法指令异常。

**添加测试**：

```rust
// 在 kernel_main 中添加
println!("\n测试非法指令异常...");
unsafe {
    core::arch::asm!(".word 0x00000000");  // 全 0 是非法指令
}
println!("这行不会执行");
```

**运行后会触发 panic**，因为我们的 `illegal_instruction_handler` 会调用 `panic!()`。

---

#### 验证异常返回机制

**测试代码**：

```rust
#[no_mangle]
pub extern "C" fn kernel_main() -> ! {
    println!("Welcome to Error OS!");
    os::init();

    println!("\n验证异常返回机制...\n");

    let mut counter = 0;

    for i in 0..5 {
        println!("迭代 {}", i);
        counter += 1;

        // 触发断点异常
        unsafe {
            core::arch::asm!("ebreak");
        }

        // 如果异常返回正确，这行会执行
        println!("  counter = {}", counter);
    }

    println!("\n验证成功！异常返回机制正常工作。\n");

    os::hlt_loop();
}
```

**预期输出**：

```
迭代 0
[EXCEPTION] Breakpoint at 0x80xxxxxx
EXCEPTION: BREAKPOINT at 0x80xxxxxx
  counter = 1
迭代 1
[EXCEPTION] Breakpoint at 0x80xxxxxx
EXCEPTION: BREAKPOINT at 0x80xxxxxx
  counter = 2
...
验证成功！异常返回机制正常工作。
```

如果每次断点后都能正常继续执行，说明上下文保存和恢复正确。
