## 2.3 中断描述符表（IDT）

#### 什么是中断描述符表？

在传统的 x86 架构中，**中断描述符表（IDT，Interrupt Descriptor Table）** 是一个包含 256 个表项的数组，每个表项指向一个中断或异常的处理函数。当中断或异常发生时，CPU 根据中断号在表中查找对应的处理函数地址，然后跳转执行。

但 RISC-V 采用了**更简洁的设计理念**：

- **x86 方式**：维护一个大型表格（256项），每个中断/异常有独立的入口地址
- **RISC-V 方式**：只配置一个或少量几个统一入口点，由软件读取异常原因后进行分发

#### RISC-V 的陷阱向量机制

RISC-V 使用 **stvec（Supervisor Trap Vector）寄存器** 来指定异常和中断的处理入口地址。当异常或中断发生时：

1. 硬件自动将 PC 设置为 stvec 指向的地址
2. 同时更新 scause、sepc、stval 等寄存器
3. 将特权级切换到 S-mode（如果从 U-mode 来）
4. 禁用中断（sstatus.SIE = 0）

```
        用户程序执行
             ↓
      触发异常/中断
             ↓
    硬件自动跳转到 stvec
             ↓
      trap_handler 函数
             ↓
        读取 scause
             ↓
      根据类型分发处理
```

为什么 RISC-V 这样设计？有一个形象的比喻：

- **x86 的 IDT**：就像一个大型医院，有 256 个专科窗口，每种病症直接去对应窗口
- **RISC-V 的 stvec**：就像一个智能导诊台，所有患者先到导诊台，由护士判断后引导到相应科室

对于操作系统开发者来说，RISC-V 的方式更加清晰和可控。

---

#### 配置 stvec 寄存器

前面有讲过 stvec 寄存器的格式：

```
63                            2    1  0
┌──────────────────────────────┬─────┐
│         BASE                 │ MODE│
│     (异常处理程序基地址)        │     │
└──────────────────────────────┴─────┘
```

**BASE[63:2]**：异常处理入口函数的地址，指向我们的 `trap_handler` 函数（必须是 4 字节对齐的）

**MODE[1:0]**：

`00` (0) = **Direct 模式**：所有异常/中断都跳转到 BASE 地址

`01` (1) = **Vectored 模式**：根据异常原因跳转到不同地址



在 [os/src/interrupts.rs](../os/src/interrupts.rs)中让我们看看如何初始化 IDT：

```rust
// os/src/interrupts.rs

use riscv::register::{
    scause::{self, Exception, Interrupt, Trap},
    sepc, stval, stvec,
};

/// 初始化中断描述符表（RISC-V 陷阱向量）
///
/// # 功能
/// - 设置 stvec 寄存器指向中断处理入口
/// - 启用 S-mode 中断
/// - 启用并设置定时器中断
pub fn init_idt() {
    unsafe {
        // 设置陷阱向量地址（Direct 模式）
        // 所有中断和异常都跳转到同一个处理函数
        stvec::write(trap_handler as usize, stvec::TrapMode::Direct);
    }

    serial_println!("[INTERRUPT] Trap vector initialized");

    // 启用定时器中断
    unsafe {
        // 启用 sie 寄存器中的 timer 中断位
        riscv::register::sie::set_stimer();
    }

    // 设置第一个定时器中断
    set_next_timer();

    serial_println!("[INTERRUPT] Timer interrupt enabled");
}
```

#### 代码详解

让我们逐行理解这段代码：

**1. 设置 stvec 寄存器**

```rust
stvec::write(trap_handler as usize, stvec::TrapMode::Direct);
```

- `trap_handler`：这是我们的异常处理函数（稍后会看到）
- `as usize`：将函数指针转换为地址值
- `stvec::TrapMode::Direct`：使用 Direct 模式
- `unsafe`：因为修改 CSR 寄存器是不安全操作

这行代码告诉 CPU：**当任何异常或中断发生时，请跳转到 `trap_handler` 函数**。

**2. 启用定时器中断**

```rust
riscv::register::sie::set_stimer();
```

- `sie` 是 Supervisor Interrupt Enable 寄存器
- `set_stimer()` 使能定时器中断位
- 这样 CPU 才会响应定时器中断

**3. 设置定时器**

```rust
set_next_timer();
```

- 通过 SBI 调用设置下一次定时器中断的时间
- 定时器中断用于任务调度和时间管理

#### 在内核初始化时调用

在 [os/src/lib.rs](../os/src/lib.rs) 的 `init()` 函数中，我们调用了 IDT 的初始化：

```rust
// os/src/lib.rs

/// 初始化操作系统
pub fn init() {
    serial_println!("[INIT] Initializing RISC-V OS");

    // 初始化中断系统
    interrupts::init_idt();

    // 启用中断
    interrupts::enable_interrupts();

    serial_println!("[INIT] Initialization complete");
}
```

然后在 [os/src/main.rs](../os/src/main.rs) 的 `kernel_main` 函数中调用：

```rust
// os/src/main.rs

#[no_mangle]
pub extern "C" fn kernel_main() -> ! {
    println!("Welcome to Error OS!");

    // 初始化操作系统（包括中断系统）
    os::init();

    // ... 其他代码 ...
}
```

#### 验证配置结果

编译并运行内核后，你应该能在串口输出中看到以下日志：

```
[INIT] Initializing RISC-V OS
[INTERRUPT] Trap vector initialized
[INTERRUPT] Timer interrupt enabled
[INIT] Initialization complete
```

这说明中断系统已经成功初始化！

---

#### 实现统一的异常分发器

现在让我们看看 `trap_handler` 函数是如何工作的。这是所有异常和中断的统一入口点：

```rust
// os/src/interrupts.rs

/// 统一的陷阱处理入口
///
/// # 功能
/// - 读取 scause 寄存器判断中断/异常类型
/// - 分发到对应的处理函数
///
/// # 参数
/// - 通过 CSR 寄存器传递上下文信息
#[no_mangle]
pub extern "C" fn trap_handler() {
    // 读取异常相关的 CSR 寄存器
    let scause = scause::read();  // 异常原因
    let stval = stval::read();    // 异常相关值
    let sepc = sepc::read();      // 异常发生时的 PC

    // 根据异常类型进行分发
    match scause.cause() {
        // ============================================
        // 中断处理
        // ============================================
        Trap::Interrupt(interrupt) => {
            match interrupt {
                Interrupt::SupervisorTimer => {
                    timer_interrupt_handler();
                }
                Interrupt::SupervisorExternal => {
                    external_interrupt_handler();
                }
                Interrupt::SupervisorSoft => {
                    software_interrupt_handler();
                }
                _ => {
                    panic!(
                        "Unhandled interrupt!\n\
                        scause: {:?}\n\
                        sepc: {:#x}\n\
                        stval: {:#x}",
                        scause.cause(),
                        sepc,
                        stval
                    );
                }
            }
        }

        // ============================================
        // 异常处理
        // ============================================
        Trap::Exception(exception) => {
            match exception {
                Exception::Breakpoint => {
                    breakpoint_handler(sepc);
                }
                Exception::LoadPageFault |
                Exception::StorePageFault |
                Exception::InstructionPageFault => {
                    page_fault_handler(scause.cause(), stval, sepc);
                }
                Exception::IllegalInstruction => {
                    illegal_instruction_handler(sepc, stval);
                }
                Exception::UserEnvCall => {
                    // 系统调用处理入口（预留，后续章节实现）
                    panic!(
                        "System call not implemented!\n\
                        sepc: {:#x}",
                        sepc
                    );
                }
                _ => {
                    panic!(
                        "Unhandled exception!\n\
                        scause: {:?}\n\
                        sepc: {:#x}\n\
                        stval: {:#x}",
                        scause.cause(),
                        sepc,
                        stval
                    );
                }
            }
        }
    }
}
```

#### 代码详解

**1. 读取异常信息**

```rust
let scause = scause::read();  // 异常原因
let stval = stval::read();    // 异常相关值
let sepc = sepc::read();      // 异常发生时的 PC
```

当异常发生时，硬件会自动设置这些 CSR 寄存器：
- **scause**：告诉我们是什么类型的异常或中断
- **stval**：提供额外信息（如页面错误的地址）
- **sepc**：告诉我们异常发生在哪里

**2. 第一层分发：中断 vs 异常**

```rust
match scause.cause() {
    Trap::Interrupt(interrupt) => { /* 处理中断 */ }
    Trap::Exception(exception) => { /* 处理异常 */ }
}
```

通过 `scause` 的最高位，我们可以区分：
- 中断（Interrupt）：异步事件，由外部硬件触发
- 异常（Exception）：同步事件，由指令执行引起

**3. 第二层分发：具体类型**

对于中断：
```rust
match interrupt {
    Interrupt::SupervisorTimer => timer_interrupt_handler(),
    Interrupt::SupervisorExternal => external_interrupt_handler(),
    Interrupt::SupervisorSoft => software_interrupt_handler(),
    _ => panic!("Unhandled interrupt"),
}
```

对于异常：
```rust
match exception {
    Exception::Breakpoint => breakpoint_handler(sepc),
    Exception::LoadPageFault |
    Exception::StorePageFault |
    Exception::InstructionPageFault => page_fault_handler(...),
    Exception::IllegalInstruction => illegal_instruction_handler(...),
    // ... 更多异常类型
}
```

我们看几个具体的处理函数实现：

**断点异常处理**

```rust
/// 断点异常处理
///
/// # 参数
/// - `sepc`: 异常发生时的程序计数器
fn breakpoint_handler(sepc: usize) {
    serial_println!("[EXCEPTION] Breakpoint at {:#x}", sepc);
    println!("EXCEPTION: BREAKPOINT at {:#x}", sepc);

    // 断点指令后继续执行（跳过 ebreak 指令）
    riscv::register::sepc::write(sepc + 2); // ebreak 是 2 字节指令
}
```

**定时器中断处理**

```rust
/// 时钟中断处理
fn timer_interrupt_handler() {
    // 轮询键盘输入（通过 SBI console）
    crate::task::keyboard::poll_keyboard();

    // 设置下一次定时器中断
    set_next_timer();
}
```

**页面错误处理**

```rust
/// 页错误处理
fn page_fault_handler(cause: Trap, stval: usize, sepc: usize) {
    serial_println!(
        "[EXCEPTION] Page Fault\n\
        Type: {:?}\n\
        Address: {:#x}\n\
        PC: {:#x}",
        cause,
        stval,
        sepc
    );

    println!("EXCEPTION: PAGE FAULT");
    println!("Accessed Address: {:#x}", stval);
    println!("Exception PC: {:#x}", sepc);
    println!("Fault Type: {:?}", cause);

    crate::hlt_loop();
}
```
