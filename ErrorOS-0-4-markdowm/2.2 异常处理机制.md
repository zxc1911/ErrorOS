## 2.2 异常处理机制

这一节中我们要深入了解 RISC-V 的异常处理机制。当异常或中断发生时，CPU 会自动执行一系列步骤。

> 异常是由**当前执行的指令**引起的同步事件，例如：执行了非法指令、访问了无效的内存地址、执行了 `ecall`（系统调用）、执行了 `ebreak`（断点）
>
> 中断是由**外部硬件**引起的异步事件，例如：定时器中断（时钟到期）、外部设备中断（键盘、网卡等）、软件中断
>
> 用一个形象的比喻来讲的话，**异常**好比你在做作业时遇到不会的题，主动举手问老师（同步，由你的动作引起）；而**中断**就是你在做作业时突然下课铃响了（异步，外部事件）
>
> RISC-V 通过 `scause` 寄存器的最高位来区分：
>
> - `scause[63] = 0`：异常（Exception）
> - `scause[63] = 1`：中断（Interrupt）
>

#### 理解 stvec 寄存器（异常向量表）

`stvec`（Supervisor Trap Vector）是一个指向**异常处理程序**的指针。当异常或中断发生时，CPU 会跳转到 `stvec` 指向的地址。

**stvec 的结构：**

```
63                            2    1  0
┌──────────────────────────────┬─────┐
│         BASE                 │ MODE│
│     (异常处理程序基地址)        │     │
└──────────────────────────────┴─────┘
```

**BASE[63:2]**：异常处理程序的基地址（4 字节对齐）

**MODE[1:0]**：

- `0`：Direct 模式（所有异常跳转到 BASE）
- `1`：Vectored 模式（根据异常类型跳转到 BASE + 4×cause）

**两种模式的区别**

1. **Direct 模式:**
   - 所有异常都跳转到同一个地址
   - 在异常处理程序中读取 `scause` 来判断异常类型
   - 简单，易于实现

2. **Vectored 模式:**
   - 不同异常跳转到不同地址
   - 需要在 BASE 地址处建立跳转表
   - 更快，但实现复杂

**我们将使用 Direct 模式**

```rust
// 设置 stvec 为 Direct 模式
unsafe {
    stvec::write(trap_handler as usize, TrapMode::Direct);
}
```

---

#### 理解 scause 寄存器（异常原因）

`scause`（Supervisor Cause）记录了异常或中断的**原因**。通过读取这个寄存器，我们可以知道发生了什么事件。

**scause 的结构**

```
63     62                                   0
┌────┬──────────────────────────────────────┐
│INT │         Exception Code               │
└────┴──────────────────────────────────────┘
```

**INT（bit 63）**体现出是中断还是异常

- `0`：异常（Exception）
- `1`：中断（Interrupt）

**Exception Code（bits 62:0）**：具体的异常/中断编号

**常见的异常编号**

| 编号 | 名称                           | 说明             |
| ---- | ------------------------------ | ---------------- |
| 0    | Instruction Address Misaligned | 指令地址未对齐   |
| 1    | Instruction Access Fault       | 指令访问错误     |
| 2    | Illegal Instruction            | 非法指令         |
| 3    | Breakpoint                     | 断点（ebreak）   |
| 8    | Environment Call from U-mode   | 用户模式系统调用 |
| 9    | Environment Call from S-mode   | 监管模式系统调用 |
| 12   | Instruction Page Fault         | 指令页面错误     |
| 13   | Load Page Fault                | 加载页面错误     |
| 15   | Store/AMO Page Fault           | 存储页面错误     |

**常见的中断编号**

| 编号 | 名称                          | 说明       |
| ---- | ----------------------------- | ---------- |
| 1    | Supervisor Software Interrupt | 软件中断   |
| 5    | Supervisor Timer Interrupt    | 定时器中断 |
| 9    | Supervisor External Interrupt | 外部中断   |

**在 Rust 中读取 scause**

```rust
use riscv::register::scause::{self, Trap, Exception, Interrupt};

let cause = scause::read();
match cause.cause() {
    Trap::Exception(Exception::Breakpoint) => {
        println!("Breakpoint exception!");
    }
    Trap::Interrupt(Interrupt::SupervisorTimer) => {
        println!("Timer interrupt!");
    }
    _ => {
        println!("Unknown trap: {:?}", cause.cause());
    }
}
```

---

#### 理解 sepc 寄存器（异常返回地址）

`sepc`（Supervisor Exception Program Counter）保存了**异常发生时的 PC 值**，即引起异常的指令地址。

```rust
// 读取异常发生的地址
let exception_pc = sepc::read();
println!("Exception occurred at: 0x{:x}", exception_pc);

// 处理系统调用异常时，需要跳过 ecall 指令
if cause.code() == Exception::EnvironmentCallFromUMode as usize {
    sepc::write(sepc::read() + 4);  // ecall 指令是 4 字节
}
```

---

#### 理解 stval 寄存器（异常相关值）

`stval`（Supervisor Trap Value）保存了与异常相关的**额外信息**。不同类型的异常，`stval` 的含义不同。

**stval 的内容**

| 异常类型            | stval 的值             |
| ------------------- | ---------------------- |
| 指令地址未对齐      | 导致异常的地址         |
| 指令访问错误        | 导致异常的地址         |
| 非法指令            | 导致异常的指令编码     |
| 断点                | 触发断点的地址         |
| 加载/存储地址未对齐 | 导致异常的地址         |
| 页面错误            | 导致页面错误的虚拟地址 |
| 其他异常            | 0（未定义）            |



`stval` 最常用于**页面错误**处理（后续章节）：

```rust
// 处理页面错误
if cause.code() == Exception::LoadPageFault as usize {
    let fault_address = stval::read();
    println!("Page fault at address: 0x{:x}", fault_address);
    // 分配物理页面并建立映射...
}
```

---

#### 理解 sstatus 寄存器（状态寄存器）

`sstatus`（Supervisor Status）是一个**状态寄存器**，包含了多个控制位，用于控制 CPU 的行为。

**sstatus 的重要字段**

```
63        9  8   7  6  5    4   3  2  1   0
┌─────────┬──┬───┬──┬──┬────┬───┬──┬──┬───┐
│   ...   │SD│...│FS│XS│ ...│SPP│..│SIE│
└─────────┴──┴───┴──┴──┴────┴───┴──┴──┴───┘
```

**SIE（Supervisor Interrupt Enable，bit 1）**是全局中断开关，`1`：使能 S-mode 中断；`0`：禁用 S-mode 中断。

**SPIE（Supervisor Previous Interrupt Enable，bit 5）**，保存异常发生前的 SIE 值，从异常返回时恢复。

**SPP（Supervisor Previous Privilege，bit 8）**，保存异常发生前的特权级。`0`：U-mode，`1`：S-mode



当异常发生时，CPU 会自动：

1. `sstatus.SPIE = sstatus.SIE`（保存旧的中断使能状态）
2. `sstatus.SIE = 0`（禁用中断，防止嵌套）
3. `sstatus.SPP = 当前特权级`（保存旧的特权级）

当执行 `sret` 返回时，CPU 会自动：

1. `sstatus.SIE = sstatus.SPIE`（恢复中断使能状态）
2. `特权级 = sstatus.SPP`（恢复特权级）

**在 Rust 中使用 sstatus**

```rust
use riscv::register::sstatus;

// 使能中断
unsafe {
    sstatus::set_sie();  // SIE = 1
}

// 禁用中断
unsafe {
    sstatus::clear_sie();  // SIE = 0
}

// 读取状态
let sie = sstatus::read().sie();
println!("Interrupt enabled: {}", sie);
```
