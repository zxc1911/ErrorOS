## 3.5 实现堆分配器

堆是用于动态内存分配的内存区域，栈和堆的区别请读者自己了解一下，这里就不再赘述。堆的大小在编译时未知且生命周期灵活。



Rust 通过 `GlobalAlloc` trait 定义全局分配器接口：

```rust
pub unsafe trait GlobalAlloc {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8;
    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout);
}
```

---

#### 实现 Bump Allocator（堆版本）

我们已经在 `os/src/allocator/bump.rs` 中有实现，让我们理解它的工作原理。

**查看 bump.rs**

这个文件实现了堆的 Bump Allocator：

```rust
pub struct BumpAllocator {
    heap_start: usize,  // 堆起始地址
    heap_end: usize,    // 堆结束地址
    next: usize,        // 下一个分配位置
    allocations: usize, // 已分配次数
}
```

**工作原理**

```
初始化：
┌────────────────────────────────────┐
│  heap_start                heap_end│
│  ↓                              ↓  │
│  [        可用堆空间          ]      │
│   ^                                │
│   next                             │
└────────────────────────────────────┘

分配 16 字节（对齐到 8）：
┌────────────────────────────────────┐
│  [已分配 16B][     可用空间    ]     │
│              ^                     │
│              next (next += 16)     │
└────────────────────────────────────┘

继续分配 32 字节：
┌────────────────────────────────────┐
│  [16B][32B][      可用空间     ]    │
│            ^                       │
│            next (next += 32)       │
└────────────────────────────────────┘
```

**关键函数：alloc**

```rust
unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
    let mut bump = self.lock();

    // 1. 对齐 next 到 layout.align()
    let alloc_start = align_up(bump.next, layout.align());

    // 2. 计算分配结束位置
    let alloc_end = alloc_start + layout.size();

    // 3. 检查是否超出堆范围
    if alloc_end > bump.heap_end {
        return ptr::null_mut();  // 内存不足
    }

    // 4. 更新 next 指针
    bump.next = alloc_end;
    bump.allocations += 1;

    // 5. 返回分配的地址
    alloc_start as *mut u8
}
```

**align_up 函数**

```rust
fn align_up(addr: usize, align: usize) -> usize {
    (addr + align - 1) & !(align - 1)
}
```

**例子**：

- `align_up(0x1003, 8)` = `0x1008`
- `align_up(0x1000, 8)` = `0x1000`

**为什么需要对齐？**

1. **硬件要求**：某些 CPU 要求数据按特定边界对齐
2. **性能**：对齐的内存访问更快
3. **正确性**：某些指令（如 SIMD）要求严格对齐

---

#### 实现 Linked List Allocator

Linked List Allocator 比 Bump Allocator 更实用，因为它支持释放和重用内存。

**基本原理**

```
空闲链表结构：
┌─────────────────────────────────────────┐
│ 头节点 (虚拟)                            │
│  next ────────┐                         │
└───────────────┼─────────────────────────┘
                ↓
        ┌───────────────┐
        │ 空闲块 1      │ size = 64
        │ next ─────┐   │
        └───────────┼───┘
                    ↓
            ┌───────────────┐
            │ 空闲块 2      │ size = 128
            │ next ─────┐   │
            └───────────┼───┘
                        ↓
                      None

分配请求 32 字节：
1. 遍历链表，找到足够大的块（块 1: 64 字节）
2. 从块 1 中分配 32 字节
3. 剩余 32 字节继续作为空闲块

释放内存：
1. 将释放的块重新加入链表
2. 尝试合并相邻的空闲块
```

我们项目中的 `os/src/allocator/linked_list.rs` 已经实现了这个分配器。

---

#### 实现 Fixed Size Block Allocator

这是我们项目中使用的分配器，结合了固定大小和 fallback 机制。

**工作原理**

```
固定大小块池：
[8B 块]  → [块1] → [块2] → [块3] → ...
[16B 块] → [块1] → [块2] → ...
[32B 块] → [块1] → [块2] → ...
[64B 块] → ...
...
[2KB 块] → ...

后备分配器（Linked List）：
用于大于 2KB 的分配

分配策略：
1. 如果 size ≤ 2KB，从对应的固定大小块池分配
2. 如果 size > 2KB，使用后备分配器
3. 如果固定大小块池为空，从后备分配器分配新块
```

---

#### 初始化堆分配器

现在让我们初始化堆分配器，使 `Box`、`Vec` 等类型可用。

查看 `os/src/allocator.rs`，找到初始化函数：

```rust
pub fn init_heap_simple(kernel_end_addr: usize) -> Result<(), &'static str> {
    // 1. 将堆起始地址对齐到 4KB
    let heap_start = align_up(kernel_end_addr, 4096);

    // 2. 打印调试信息
    serial_println!("[ALLOCATOR] Initializing heap at {:#x}", heap_start);
    serial_println!("[ALLOCATOR] Heap size: {} bytes", HEAP_SIZE);

    // 3. 初始化全局分配器
    unsafe {
        ALLOCATOR.lock().init(heap_start, HEAP_SIZE);
    }

    serial_println!("[ALLOCATOR] Heap initialized successfully");
    Ok(())
}
```

我们在项目的 `os/src/main.rs` 中已经调用了初始化：

```rust
#[no_mangle]
pub extern "C" fn kernel_main() -> ! {
    use os::allocator;

    println!("Welcome to Error OS!");
    os::init();

    // 获取内核结束地址
    extern "C" {
        static kernel_end: u8;
    }
    let kernel_end_addr = unsafe { &kernel_end as *const u8 as usize };

    // 初始化堆分配器
    allocator::init_heap_simple(kernel_end_addr)
        .expect("heap initialization failed");

    // 现在可以使用 Box, Vec 等类型了！

    os::hlt_loop();
}
```
