## 3.1 物理内存管理

#### QEMU virt 机器的内存映射

在开始实现物理内存管理之前,我们需要先理解 RISC-V QEMU virt 虚拟机的内存布局。

**完整的内存映射**

```
物理地址空间布局（QEMU virt 机器，128MB 内存配置）
┌────────────────────────────────┐ 0x0000_0000
│  保留区域                       │
├────────────────────────────────┤ 0x0000_1000
│  MROM (Mask ROM)               │ 启动代码
├────────────────────────────────┤ 0x0000_4000
│  测试设备                       │
├────────────────────────────────┤ 0x0010_0000
│  UART0 (串口)                   │ ← 我们用它来输出
├────────────────────────────────┤ 0x0010_0100
│  其他设备寄存器...               │
├────────────────────────────────┤ 0x0c00_0000
│  PLIC (中断控制器)               │
├────────────────────────────────┤ 0x1000_0000
│  DRAM (物理内存)                │
│  ┌──────────────────────────┐  │ 0x8000_0000
│  │  OpenSBI 固件 (256KB)     │  │ ← BIOS
│  ├──────────────────────────┤  │ 0x8020_0000
│  │  内核代码段 (.text)        │  │ ← 我们的内核加载位置
│  ├──────────────────────────┤  │
│  │  内核只读数据 (.rodata)    │  │
│  ├──────────────────────────┤  │
│  │  内核数据段 (.data)        │  │
│  ├──────────────────────────┤  │
│  │  内核 BSS 段 (.bss)       │  │
│  ├──────────────────────────┤  │ kernel_end
│  │  可用物理内存              │  │ ← 我们要管理的区域
│  │  (用于动态分配)            │  │
│  └──────────────────────────┘  │
└────────────────────────────────┘ 0x8800_0000 (128MB 内存终点)
```

**关键地址说明**

| 地址范围                    | 大小   | 用途             | 是否可用   |
| --------------------------- | ------ | ---------------- | ---------- |
| `0x0000_0000 - 0x0000_1000` | 4KB    | 保留区域         | 不可用     |
| `0x0010_0000 - 0x0010_0100` | 256B   | UART 串口设备    | 设备寄存器 |
| `0x0c00_0000 - 0x1000_0000` | 64MB   | PLIC 中断控制器  | 设备寄存器 |
| `0x8000_0000 - 0x8020_0000` | 2MB    | OpenSBI 固件     | 不可用     |
| `0x8020_0000 - kernel_end`  | 变化   | 内核代码和数据   | 不可用     |
| `kernel_end - 0x8800_0000`  | ~126MB | **可用物理内存** | 可分配     |

这是 RISC-V 规范定义约定：

1. **0x0000_0000 - 0x8000_0000**：I/O 设备地址空间
2. **0x8000_0000 开始**：物理内存（DRAM）

这种设计的好处：

- 设备地址和内存地址分离，易于管理
- 符合 RISC-V SBI 规范，便于固件加载

---

#### 通过链接器脚本控制内存布局

在第0章中，我们已经编写了链接器脚本 `linker-riscv64.ld`。现在让我们回顾一下它如何控制内核的内存布局。

**回顾链接器脚本的关键部分**

```ld
/* 内核加载到 0x80200000（OpenSBI 之后） */
. = 0x80200000;

kernel_start = .;

/* .text 段：代码段 */
.text : ALIGN(4K) {
    *(.text.entry)      /* 入口代码（_start 函数） */
    *(.text .text.*)    /* 所有代码 */
}

/* .rodata 段：只读数据段 */
.rodata : ALIGN(4K) {
    *(.rodata .rodata.*)
}

/* .data 段：已初始化数据段 */
.data : ALIGN(4K) {
    *(.data .data.*)
}

/* .bss 段：未初始化数据段 */
.bss : ALIGN(4K) {
    bss_start = .;
    *(.bss .bss.*)
    bss_end = .;
}

kernel_end = .;
```

**链接器脚本导出的符号**

这些符号可以在 Rust 代码中通过 `extern "C"` 访问：

```rust
extern "C" {
    static kernel_start: u8;   // 内核起始地址
    static kernel_end: u8;     // 内核结束地址
    static bss_start: u8;      // BSS 段起始
    static bss_end: u8;        // BSS 段结束
}

// 使用示例
let kernel_start_addr = unsafe { &kernel_start as *const u8 as usize };
let kernel_end_addr = unsafe { &kernel_end as *const u8 as usize };
```

**为什么需要知道这些地址？**

1. **确定可用内存的起始位置**
   - 可用内存从 `kernel_end` 开始
   - 到 `0x8800_0000` (128MB 终点)

2. **初始化 BSS 段**
   - 在启动时需要将 BSS 段清零
   - 我们在 `_start` 汇编代码中已经完成

3. **实现内存分配器**
   - 分配器需要知道可管理的内存范围
   - 避免分配内核占用的区域

---

#### 理解段的概念

**什么是"段"（Section）？**

段是程序在内存中的逻辑分区，每个段存储不同类型的数据：

```
内核内存布局示意图：

┌───────────────────────────┐ 0x8020_0000 (kernel_start)
│  .text 段                 │
│  ┌─────────────────────┐  │
│  │ _start (汇编入口)    │  │
│  │ kernel_main         │  │
│  │ 其他函数代码...       │  │
│  └─────────────────────┘  │
├───────────────────────────┤
│  .rodata 段                │
│  ┌─────────────────────┐  │
│  │ 字符串常量            │  │
│  │ const 常量           │  │
│  └─────────────────────┘  │
├───────────────────────────┤
│  .data 段                 │
│  ┌─────────────────────┐  │
│  │ 已初始化的全局变量     │  │
│  │ static mut 变量      │  │
│  └─────────────────────┘  │
├───────────────────────────┤ bss_start
│  .bss 段                  │
│  ┌─────────────────────┐  │
│  │ 未初始化的全局变量     │  │
│  │ (启动时清零)          │  │
│  └─────────────────────┘  │
└───────────────────────────┘ bss_end / kernel_end
```

---

#### 可视化内存布局

为了更好地理解内存布局，让我们编写一个函数来打印内存信息。

**创建内存模块**

在 `os/src/` 目录下创建新文件 `memory.rs`：

```bash
cd os/src
touch memory.rs
```

**在 lib.rs 中声明模块**

编辑 `os/src/lib.rs`，添加：

```rust
pub mod memory;
```

**实现内存布局打印函数**

编辑 `os/src/memory.rs`，添加以下代码：

```rust
/*
 * ============================================
 * 物理内存管理模块
 * ============================================
 * 功能：管理物理内存的分配和回收
 * 包括：
 * - 物理地址抽象
 * - 物理页帧管理
 * - 堆分配器
 * ============================================
 */

use crate::serial_println;

/// 页大小：4KB（RISC-V 标准页大小）
pub const PAGE_SIZE: usize = 4096;

/// DRAM 物理内存起始地址
pub const MEMORY_START: usize = 0x8000_0000;

/// DRAM 物理内存结束地址（128MB）
pub const MEMORY_END: usize = 0x8800_0000;

/// 内核加载地址
pub const KERNEL_BASE: usize = 0x8020_0000;

/// 打印物理内存布局
///
/// # 功能
/// - 显示各个段的地址范围和大小
/// - 显示可用内存的范围
pub fn print_memory_layout() {
    // 获取链接器导出的符号
    extern "C" {
        static kernel_start: u8;
        static kernel_end: u8;
        static bss_start: u8;
        static bss_end: u8;
    }

    let kernel_start_addr = unsafe { &kernel_start as *const u8 as usize };
    let kernel_end_addr = unsafe { &kernel_end as *const u8 as usize };
    let bss_start_addr = unsafe { &bss_start as *const u8 as usize };
    let bss_end_addr = unsafe { &bss_end as *const u8 as usize };

    serial_println!("\n========================================");
    serial_println!("  物理内存布局");
    serial_println!("========================================");

    serial_println!("\n[内存范围]");
    serial_println!("  DRAM 起始:     {:#010x}", MEMORY_START);
    serial_println!("  DRAM 结束:     {:#010x}", MEMORY_END);
    serial_println!("  DRAM 大小:     {} MB", (MEMORY_END - MEMORY_START) / 1024 / 1024);

    serial_println!("\n[内核布局]");
    serial_println!("  内核起始:      {:#010x}", kernel_start_addr);
    serial_println!("  内核结束:      {:#010x}", kernel_end_addr);
    serial_println!("  内核大小:      {} KB", (kernel_end_addr - kernel_start_addr) / 1024);

    serial_println!("\n[段信息]");
    serial_println!("  BSS 起始:      {:#010x}", bss_start_addr);
    serial_println!("  BSS 结束:      {:#010x}", bss_end_addr);
    serial_println!("  BSS 大小:      {} bytes", bss_end_addr - bss_start_addr);

    let available_start = kernel_end_addr;
    let available_size = MEMORY_END - available_start;

    serial_println!("\n[可用内存]");
    serial_println!("  起始地址:      {:#010x}", available_start);
    serial_println!("  结束地址:      {:#010x}", MEMORY_END);
    serial_println!("  可用大小:      {} MB ({} KB)",
        available_size / 1024 / 1024,
        available_size / 1024
    );
    serial_println!("  可用页数:      {} 页 (每页 {} bytes)",
        available_size / PAGE_SIZE,
        PAGE_SIZE
    );

    serial_println!("========================================\n");
}
```

**在 main.rs 中调用**

编辑 `os/src/main.rs`，在 `kernel_main` 中添加：

```rust
#[no_mangle]
pub extern "C" fn kernel_main() -> ! {
    println!("Welcome to Error OS!");

    // 初始化操作系统
    os::init();

    // 打印内存布局
    os::memory::print_memory_layout();

    // ... 其他代码 ...

    os::hlt_loop();
}
```

**编译并运行**

```bash
cd os
cargo build --release

# 运行 QEMU
qemu-system-riscv64 \
    -machine virt \
    -cpu rv64 \
    -smp 1 \
    -m 128M \
    -bios default \
    -nographic \
    -serial stdio \
    -kernel target/riscv64imac-unknown-none-elf/release/os
```

**预期输出**

你应该看到类似这样的输出：

```
Welcome to Error OS!
[INIT] Initializing RISC-V OS
[INTERRUPT] Trap vector initialized
[INTERRUPT] Timer interrupt enabled
[INIT] Initialization complete

========================================
  物理内存布局
========================================

[内存范围]
  DRAM 起始:     0x80000000
  DRAM 结束:     0x88000000
  DRAM 大小:     128 MB

[内核布局]
  内核起始:      0x80200000
  内核结束:      0x80350000
  内核大小:      1344 KB

[段信息]
  BSS 起始:      0x80330000
  BSS 结束:      0x80350000
  BSS 大小:      131072 bytes

[可用内存]
  起始地址:      0x80350000
  结束地址:      0x88000000
  可用大小:      124 MB (127232 KB)
  可用页数:      31070 页 (每页 4096 bytes)
========================================
```

如果看到这样的输出，说明你已经成功理解了物理内存布局