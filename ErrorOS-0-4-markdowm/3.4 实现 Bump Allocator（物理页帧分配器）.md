## 3.4 实现 Bump Allocator（物理页帧分配器）

Bump Allocator（碰撞分配器）是最简单的内存分配器：

```
初始状态：
┌────────────────────────────────────┐
│  可用内存                           │
│  ^                                 │
│  next (指向下一个可分配位置)          │
└────────────────────────────────────┘

分配 1 个页帧后：
┌──────┬─────────────────────────────┐
│ 已分配│  可用内存                    │
│      │  ^                          │
│      │  next (向前移动)             │
└──────┴─────────────────────────────┘

继续分配 2 个页帧：
┌──────┬──────┬──────┬────────────────┐
│ 已分配│ 已分配│ 已分配│  可用内存       │
│      │      │      │  ^             │
│      │      │      │  next          │
└──────┴──────┴──────┴────────────────┘
```

---

#### 实现 BumpFrameAllocator

**定义分配器结构体**

在 `os/src/memory.rs` 中添加：

```rust
/// Bump 物理页帧分配器
///
/// # 说明
/// 最简单的分配器实现，按顺序分配页帧
/// 不支持单独释放，只支持整体重置
pub struct BumpFrameAllocator {
    /// 可管理的页帧范围
    range: PhysFrameRange,
    /// 下一个要分配的页帧
    next: PhysFrame,
}

impl BumpFrameAllocator {
    /// 创建新的分配器
    ///
    /// # 参数
    /// - `range`: 可管理的物理页帧范围
    ///
    /// # 返回
    /// BumpFrameAllocator 实例
    pub const fn new(range: PhysFrameRange) -> Self {
        Self {
            next: range.start,
            range,
        }
    }

    /// 分配一个物理页帧
    ///
    /// # 返回
    /// - `Some(PhysFrame)`: 分配成功，返回页帧
    /// - `None`: 内存不足，分配失败
    pub fn allocate(&mut self) -> Option<PhysFrame> {
        if self.next.number < self.range.end.number {
            let frame = self.next;
            self.next = PhysFrame::from_number(self.next.number + 1);
            Some(frame)
        } else {
            // 内存耗尽
            None
        }
    }

    /// 释放一个物理页帧（占位实现，不做任何事）
    ///
    /// # 参数
    /// - `_frame`: 要释放的页帧
    ///
    /// # 说明
    /// Bump Allocator 不支持单独释放
    /// 此函数仅为接口兼容性而保留
    pub fn deallocate(&mut self, _frame: PhysFrame) {
        // Bump allocator 不支持单独释放
        // 实际应用中应该 panic 或警告
    }

    /// 获取已分配的页帧数量
    pub fn allocated_count(&self) -> usize {
        self.next.number - self.range.start.number
    }

    /// 获取剩余可用页帧数量
    pub fn available_count(&self) -> usize {
        self.range.end.number - self.next.number
    }

    /// 重置分配器（释放所有已分配的页帧）
    ///
    /// # 危险
    /// 此操作会使所有之前分配的页帧失效
    /// 使用前确保没有代码在使用这些页帧
    pub fn reset(&mut self) {
        self.next = self.range.start;
    }
}

impl fmt::Debug for BumpFrameAllocator {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "BumpFrameAllocator {{ range: {:?}, next: {}, allocated: {}, available: {} }}",
            self.range,
            self.next.number,
            self.allocated_count(),
            self.available_count()
        )
    }
}
```

---

#### 测试 Bump Allocator

**添加测试函数**

```rust
/// 测试 Bump 分配器
pub fn test_bump_allocator() {
    use crate::println;

    println!("\n========================================");
    println!("  测试 BumpFrameAllocator");
    println!("========================================\n");

    // 创建分配器（管理 100 个页帧）
    let start = PhysFrame::from_number(1000);
    let end = PhysFrame::from_number(1100);
    let range = PhysFrameRange::new(start, end);
    let mut allocator = BumpFrameAllocator::new(range);

    println!("[TEST 1] 初始状态");
    println!("  {:?}", allocator);

    // 测试分配
    println!("\n[TEST 2] 分配页帧");
    let frame1 = allocator.allocate();
    println!("  分配 frame1: {:?}", frame1);

    let frame2 = allocator.allocate();
    println!("  分配 frame2: {:?}", frame2);

    let frame3 = allocator.allocate();
    println!("  分配 frame3: {:?}", frame3);

    println!("  当前状态: {:?}", allocator);

    // 测试批量分配
    println!("\n[TEST 3] 批量分配");
    let mut frames = Vec::new();
    for i in 0..5 {
        if let Some(frame) = allocator.allocate() {
            frames.push(frame);
            println!("  分配 frame #{}: {:?}", i, frame);
        }
    }

    println!("  当前状态: {:?}", allocator);

    // 测试内存统计
    println!("\n[TEST 4] 内存统计");
    println!("  已分配: {} 页帧 ({} KB)",
        allocator.allocated_count(),
        allocator.allocated_count() * 4
    );
    println!("  剩余: {} 页帧 ({} KB)",
        allocator.available_count(),
        allocator.available_count() * 4
    );

    // 测试重置
    println!("\n[TEST 5] 重置分配器");
    println!("  重置前: {:?}", allocator);
    allocator.reset();
    println!("  重置后: {:?}", allocator);

    println!("\n========================================\n");
}
```

**在 main.rs 中调用**

```rust
#[no_mangle]
pub extern "C" fn kernel_main() -> ! {
    println!("Welcome to Error OS!");
    os::init();

    os::memory::print_memory_layout();
    os::memory::test_phys_addr();
    os::memory::test_phys_frame();
    os::memory::test_bump_allocator();  // 添加这行

    os::hlt_loop();
}
```

**注意**：上面的代码使用了 `Vec`，但我们还没有初始化堆分配器！所以现在编译会失败。让我们先完成堆分配器的实现。