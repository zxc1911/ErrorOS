## 1.1 去除标准库依赖

#### 添加 `#![no_std]` 声明

**背景知识**

在编写操作系统内核时，我们无法使用 Rust 标准库（`std`），因为：

- 标准库依赖于操作系统提供的系统调用
- 我们正在编写的就是操作系统本身
- 必须使用 `core` 和 `alloc` 库（不依赖操作系统）

**步骤 1：修改 `main.rs`**

在 `os/src/main.rs` 开头添加：

```rust
#![no_std]      // 不链接 Rust 标准库
#![no_main]     // 禁用标准入口点
```

**步骤 2：尝试编译**

```bash
cd os
cargo build
```

**预期错误**

```
error: `#[panic_handler]` function required, but not found
error: language item required, but not found: `eh_personality`
```

这些错误是正常的，我们将在后续步骤中解决。

---

#### 添加 `#![no_main]` 声明

**背景知识**

Rust 程序的标准入口点是 `main` 函数，它由 `crt0`（C 运行时）调用。在裸机环境中：

- 没有 `crt0` 运行时
- 需要自定义入口点 `_start`
- 使用 `#![no_main]` 禁用标准入口点

**说明**

我们已经在步骤 1.1.1 中添加了 `#![no_main]`，这告诉编译器：

- 不要寻找标准的 `main` 函数
- 我们将提供自定义的入口点

---

#### 实现自定义 panic handler

**背景知识**

当程序发生 panic（运行时错误）时，需要有处理函数。标准库提供了默认的 panic handler，但在 `no_std` 环境中必须自己实现。

**步骤 1：实现基础 panic handler**

在 `main.rs` 中添加：

```rust
use core::panic::PanicInfo;

/// Panic 处理函数
///
/// 当程序发生 panic 时调用此函数
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    println!("{}", info);
    loop {}
}
```

**代码解析**

- `PanicInfo` 包含 panic 的信息（位置、消息等）
- 返回类型 `!` 表示永不返回（never type）
- 使用死循环防止函数返回

**步骤 2：改进 panic handler（使用串口输出）**

稍后我们实现串口后，改进为：

```rust
#[cfg(not(test))]
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    println!("{}", info);
    os::hlt_loop();  // 使用低功耗循环
}
```

---

#### 配置 panic = "abort"

**背景知识**

Rust 的 panic 有两种处理模式：

1. **unwind**（展开）: 回溯调用栈，执行清理代码
2. **abort**（终止）: 直接终止程序

在裸机环境中，展开栈需要复杂的运行时支持，因此我们使用 `abort` 模式。

**步骤 1：配置 Cargo.toml**

在 `os/Cargo.toml` 中已经配置：

```toml
[profile.dev]
panic = "abort"

[profile.release]
panic = "abort"
```

**验证配置**

```bash
cargo build
```

现在应该不再有关于 `eh_personality` 的错误。
