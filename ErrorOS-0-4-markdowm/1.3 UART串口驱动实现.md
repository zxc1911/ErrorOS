## 1.3 UART串口驱动实现

#### 理解 UART 16550 寄存器

**背景知识**

UART (Universal Asynchronous Receiver/Transmitter) 是通用异步收发器，用于串行通信。UART 16550 是一个标准的串口控制器。

**RISC-V QEMU virt 机器的 UART 配置**

- 基地址：`0x10000000`
- 类型：16550 兼容
- 时钟频率：由 QEMU 模拟
- 默认波特率：115200

**重要寄存器**

| 偏移 | 寄存器名                           | 说明            |
| ---- | ---------------------------------- | --------------- |
| `+0` | THR (Transmitter Holding Register) | 发送数据寄存器  |
| `+0` | RBR (Receiver Buffer Register)     | 接收数据寄存器  |
| `+1` | IER (Interrupt Enable Register)    | 中断使能寄存器  |
| `+2` | FCR (FIFO Control Register)        | FIFO 控制寄存器 |
| `+3` | LCR (Line Control Register)        | 线路控制寄存器  |
| `+4` | MCR (Modem Control Register)       | 调制解调器控制  |
| `+5` | LSR (Line Status Register)         | 线路状态寄存器  |

**LSR (Line Status Register) 位定义**

| 位   | 名称              | 说明                                   |
| ---- | ----------------- | -------------------------------------- |
| 0    | Data Ready        | 接收缓冲区有数据                       |
| 5    | THR Empty         | 发送缓冲区为空（**我们需要检查这个**） |
| 6    | Transmitter Empty | 发送器空闲                             |

---

#### 封装 UART 驱动接口

**步骤 1：创建 `serial.rs` 模块**

在 `os/src/` 目录创建 `serial.rs`：

```rust
/*
 * ============================================
 * RISC-V 串口驱动模块
 * ============================================
 * 功能：提供 UART 16550 串口输出功能
 * 用途：调试输出、日志记录、与 QEMU 通信
 *
 * RISC-V QEMU virt 机器的串口地址：0x10000000
 * ============================================
 */

use core::fmt;
use spin::Mutex;
use lazy_static::lazy_static;
use volatile::Volatile;

// RISC-V QEMU virt 机器的 UART 基地址
const UART_BASE_ADDRESS: usize = 0x1000_0000;

/// UART 16550 寄存器偏移
const UART_THR: usize = 0; // Transmitter Holding Register
const UART_LSR: usize = 5; // Line Status Register

/// Line Status Register 位定义
const UART_LSR_THRE: u8 = 1 << 5; // Transmitter Holding Register Empty

/// 简单的 UART 串口驱动
pub struct SerialPort {
    base_address: usize,
}
```

---

**步骤 2：实现基本方法**

继续在 `serial.rs` 中添加：

```rust
impl SerialPort {
    /// 创建新的串口实例
    pub unsafe fn new(base_address: usize) -> Self {
        SerialPort { base_address }
    }

    /// 初始化串口
    pub fn init(&mut self) {
        // QEMU 的 UART 默认已初始化，无需额外配置
    }

    /// 发送一个字节
    fn send(&mut self, byte: u8) {
        unsafe {
            // 等待发送缓冲区为空
            while !self.is_transmit_empty() {}

            // 写入数据
            let thr = (self.base_address + UART_THR) as *mut Volatile<u8>;
            (*thr).write(byte);
        }
    }

    /// 检查发送缓冲区是否为空
    fn is_transmit_empty(&self) -> bool {
        unsafe {
            let lsr = (self.base_address + UART_LSR) as *const Volatile<u8>;
            (*lsr).read() & UART_LSR_THRE != 0
        }
    }
}
```

**代码解析**

- `Volatile<u8>`: 防止编译器优化掉 MMIO 访问
- `is_transmit_empty()`: 检查 LSR 的第 5 位（THRE）
- `send()`: 轮询等待，然后写入 THR 寄存器

---

#### 实现字节级输出

**步骤 1：实现 `fmt::Write` trait**

继续在 `serial.rs` 中添加：

```rust
impl fmt::Write for SerialPort {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        for byte in s.bytes() {
            self.send(byte);
        }
        Ok(())
    }
}
```

**步骤 2：创建全局串口实例**

```rust
lazy_static! {
    /// 全局串口实例（UART0）
    ///
    /// 使用 Mutex 保护以支持多核访问
    /// 在 RISC-V QEMU virt 机器中，UART 映射到 0x10000000
    pub static ref SERIAL1: Mutex<SerialPort> = {
        let mut serial_port = unsafe { SerialPort::new(UART_BASE_ADDRESS) };
        serial_port.init();
        Mutex::new(serial_port)
    };
}
```

**依赖说明**

- `lazy_static`: 运行时初始化静态变量
- `spin::Mutex`: 自旋锁（不依赖操作系统）

---

#### 实现格式化输出支持

**步骤 1：实现底层打印函数**

继续在 `serial.rs` 中添加：

```rust
/// 底层打印函数
///
/// # 功能
/// - 格式化输出到串口
/// - 在临界区内执行，禁用中断以防止死锁
///
/// # 参数
/// - `args`: 格式化参数
#[doc(hidden)]
pub fn _print(args: ::core::fmt::Arguments) {
    use core::fmt::Write;

    // RISC-V 中断禁用/启用
    // 使用自旋锁时禁用中断，防止死锁
    crate::interrupts::without_interrupts(|| {
        SERIAL1
            .lock()
            .write_fmt(args)
            .expect("Printing to serial failed");
    });
}
```

**注意**: 这里引用了 `crate::interrupts::without_interrupts`，我们将在第2章实现。暂时可以简化为：

```rust
#[doc(hidden)]
pub fn _print(args: ::core::fmt::Arguments) {
    use core::fmt::Write;

    SERIAL1
        .lock()
        .write_fmt(args)
        .expect("Printing to serial failed");
} 
```
