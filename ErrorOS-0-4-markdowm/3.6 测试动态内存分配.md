## 3.6 测试动态内存分配

现在我们的堆分配器已经初始化，可以使用 Rust 的动态内存类型了！

### 3.6.1 测试 Box< T >

在 `os/src/memory.rs` 中添加：

```rust
/// 测试 Box 分配
pub fn test_box_allocation() {
    extern crate alloc;
    use alloc::boxed::Box;
    use crate::println;

    println!("\n========================================");
    println!("  测试 Box<T> 动态分配");
    println!("========================================\n");

    // 测试 1：分配单个值
    println!("[TEST 1] 分配单个整数");
    let heap_value = Box::new(42);
    println!("  值: {}", *heap_value);
    println!("  地址: {:p}", &*heap_value);

    // 测试 2：分配字符串
    println!("\n[TEST 2] 分配字符串");
    let heap_str = Box::new("Hello from heap!");
    println!("  内容: {}", *heap_str);
    println!("  地址: {:p}", &*heap_str);

    // 测试 3：分配结构体
    println!("\n[TEST 3] 分配结构体");

    #[derive(Debug)]
    struct Point {
        x: i32,
        y: i32,
    }

    let point = Box::new(Point { x: 10, y: 20 });
    println!("  Point: {:?}", *point);
    println!("  地址: {:p}", &*point);

    // 测试 4：分配大对象
    println!("\n[TEST 4] 分配大数组");
    let large_array = Box::new([0u8; 1024]);  // 1KB
    println!("  数组大小: {} bytes", large_array.len());
    println!("  地址: {:p}", &large_array[0]);

    println!("\n========================================\n");
}
```

**然后在 main.rs 中调用**

```rust
#[no_mangle]
pub extern "C" fn kernel_main() -> ! {
    // ... 初始化代码 ...

    // 初始化堆分配器
    allocator::init_heap_simple(kernel_end_addr)
        .expect("heap initialization failed");

    // 测试动态内存分配
    os::memory::test_box_allocation();

    os::hlt_loop();
}
```

---

#### 测试 Vec< T >

**添加测试函数**

```rust
/// 测试 Vec<T> 动态数组
pub fn test_vec_allocation() {
    extern crate alloc;
    use alloc::vec::Vec;
    use crate::println;

    println!("\n========================================");
    println!("  测试 Vec<T> 动态数组");
    println!("========================================\n");

    // 测试 1：创建空 Vec
    println!("[TEST 1] 创建空 Vec");
    let mut vec = Vec::new();
    println!("  初始容量: {}", vec.capacity());
    println!("  初始长度: {}", vec.len());

    // 测试 2：添加元素
    println!("\n[TEST 2] 添加元素");
    for i in 0..10 {
        vec.push(i);
    }
    println!("  添加 10 个元素后:");
    println!("  长度: {}", vec.len());
    println!("  容量: {}", vec.capacity());
    println!("  内容: {:?}", vec);

    // 测试 3：Vec 自动扩容
    println!("\n[TEST 3] Vec 自动扩容");
    let initial_capacity = vec.capacity();
    for i in 10..50 {
        vec.push(i);
    }
    println!("  添加 40 个元素后:");
    println!("  长度: {}", vec.len());
    println!("  容量: {} (从 {} 扩容)", vec.capacity(), initial_capacity);

    // 测试 4：Vec 的内存地址
    println!("\n[TEST 4] Vec 的内存布局");
    println!("  Vec 结构体地址: {:p}", &vec);
    println!("  数据缓冲区地址: {:p}", vec.as_ptr());

    // 测试 5：Vec 的 pop
    println!("\n[TEST 5] Vec 的 pop 操作");
    println!("  pop 前长度: {}", vec.len());
    let last = vec.pop();
    println!("  pop 的值: {:?}", last);
    println!("  pop 后长度: {}", vec.len());

    println!("\n========================================\n");
}
```

---

#### 测试 Rc< T > 引用计数

**添加测试函数**

```rust
/// 测试 Rc<T> 引用计数
pub fn test_rc_allocation() {
    extern crate alloc;
    use alloc::rc::Rc;
    use alloc::vec;
    use crate::println;

    println!("\n========================================");
    println!("  测试 Rc<T> 引用计数");
    println!("========================================\n");

    // 测试 1：创建 Rc
    println!("[TEST 1] 创建 Rc");
    let data = Rc::new(vec![1, 2, 3, 4, 5]);
    println!("  数据: {:?}", *data);
    println!("  引用计数: {}", Rc::strong_count(&data));

    // 测试 2：clone Rc（共享所有权）
    println!("\n[TEST 2] Clone Rc");
    let data2 = Rc::clone(&data);
    println!("  data 引用计数: {}", Rc::strong_count(&data));
    println!("  data2 引用计数: {}", Rc::strong_count(&data2));
    println!("  data 和 data2 指向同一块内存: {}",
        Rc::ptr_eq(&data, &data2));

    // 测试 3：drop Rc
    println!("\n[TEST 3] Drop Rc");
    println!("  drop data2 前引用计数: {}", Rc::strong_count(&data));
    drop(data2);
    println!("  drop data2 后引用计数: {}", Rc::strong_count(&data));

    println!("\n========================================\n");
}
```

---

#### 测试内存分配失败处理

**添加测试函数**

```rust
/// 测试内存分配失败情况
pub fn test_allocation_failure() {
    extern crate alloc;
    use alloc::vec::Vec;
    use crate::{println, serial_println};

    println!("\n========================================");
    println!("  测试内存分配失败处理");
    println!("========================================\n");

    println!("[TEST 1] 尝试分配大量内存");
    println!("  堆大小: {} MB", crate::allocator::HEAP_SIZE / 1024 / 1024);

    // 尝试分配大量小对象
    let mut vecs = Vec::new();
    let mut total_allocated = 0;

    for i in 0..1000 {
        // 每次分配 1KB
        let v = Vec::with_capacity(1024);
        total_allocated += 1024;
        vecs.push(v);

        if i % 100 == 0 {
            serial_println!("  已分配 {} KB", total_allocated / 1024);
        }
    }

    println!("  成功分配 {} 个 Vec", vecs.len());
    println!("  总共分配: {} KB", total_allocated / 1024);

    println!("\n========================================\n");
}
```

---

#### 综合测试

**创建完整的测试套件**

在 `os/src/memory.rs` 中添加：

```rust
/// 运行所有内存管理测试
pub fn run_all_tests() {
    use crate::println;

    println!("\n╔════════════════════════════════════════╗");
    println!("║  物理内存管理测试套件                  ║");
    println!("╚════════════════════════════════════════╝\n");

    // 打印内存布局
    print_memory_layout();

    // 地址抽象测试
    test_phys_addr();

    // 页帧测试
    test_phys_frame();

    // 动态内存分配测试
    test_box_allocation();
    test_vec_allocation();
    test_rc_allocation();
    test_allocation_failure();

    println!("\n╔════════════════════════════════════════╗");
    println!("║  所有测试完成！                        ║");
    println!("╚════════════════════════════════════════╝\n");
}
```

**在 main.rs 中调用**

```rust
#[no_mangle]
pub extern "C" fn kernel_main() -> ! {
    use os::allocator;

    println!("Welcome to Error OS!");
    os::init();

    // 获取内核结束地址
    extern "C" {
        static kernel_end: u8;
    }
    let kernel_end_addr = unsafe { &kernel_end as *const u8 as usize };

    // 初始化堆分配器
    allocator::init_heap_simple(kernel_end_addr)
        .expect("heap initialization failed");

    // 运行完整测试套件
    os::memory::run_all_tests();

    println!("系统已就绪，按 Ctrl+A 然后 X 退出 QEMU\n");

    os::hlt_loop();
}
```

**编译并运行**

```bash
cd os
cargo build --release

# 运行 QEMU
qemu-system-riscv64 \
    -machine virt \
    -cpu rv64 \
    -smp 1 \
    -m 128M \
    -bios default \
    -nographic \
    -serial stdio \
    -kernel target/riscv64imac-unknown-none-elf/release/os
```
