## 3.3 物理页帧定义

在现代操作系统中，物理内存被划分为固定大小的"页帧"（Page Frame），虚拟内存被划分为"页"（Page）。

**为什么要分页？**

```
不使用分页（连续分配）：
┌─────────────┐
│  程序 A      │ 10KB
├─────────────┤
│  程序 B      │ 20KB
├─────────────┤
│  程序 C      │ 15KB
├─────────────┤
│  空闲        │ 5KB  ← 太小，无法使用
├─────────────┤
│  程序 D      │ 30KB
└─────────────┘

问题：
1. 内存碎片（5KB 的空闲空间无法利用）
2. 程序必须占用连续内存
3. 难以实现内存保护

使用分页（离散分配）：
┌─────┬─────┬─────┬─────┐
│ A-1 │ A-2 │ B-1 │ B-2 │  ← 程序可以不连续
├─────┼─────┼─────┼─────┤
│ B-3 │ B-4 │ C-1 │ C-2 │
├─────┼─────┼─────┼─────┤
│ C-3 │ 空闲 │ D-1 │ D-2 │  ← 每个页帧都可用
└─────┴─────┴─────┴─────┘

优势：
1. 消除外部碎片
2. 程序可以非连续分配
3. 易于实现内存保护和共享
```

**RISC-V 的分页机制**

- **页大小**：4KB (4096 字节)
- **页帧**：物理内存中的 4KB 块
- **页号**：物理地址 / 4096
- **页内偏移**：物理地址 % 4096

```
物理地址的组成：
┌─────────────────────────┬───────────────┐
│      页号 (PPN)          │ 页内偏移       │
│   Physical Page Number  │ Page Offset   │
└─────────────────────────┴───────────────┘
 63                     12 11            0

页号：高 52 位，标识哪一页
页内偏移：低 12 位，页内的字节偏移（0-4095）

例如：物理地址 0x80201234
  页号   = 0x80201234 / 4096 = 0x80201
  页偏移 = 0x80201234 % 4096 = 0x234
```

---

#### 实现 PhysFrame 结构体

**定义物理页帧类型**

在 `os/src/memory.rs` 中添加：

```rust
/// 物理页帧
///
/// # 说明
/// 代表一个 4KB 的物理内存页帧
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PhysFrame {
    /// 页帧号（物理页号，PPN）
    number: usize,
}

impl PhysFrame {
    /// 从页帧号创建
    ///
    /// # 参数
    /// - `number`: 页帧号
    ///
    /// # 返回
    /// PhysFrame 实例
    pub const fn from_number(number: usize) -> Self {
        Self { number }
    }

    /// 从物理地址创建（向下对齐）
    ///
    /// # 参数
    /// - `addr`: 物理地址
    ///
    /// # 返回
    /// 包含该地址的物理页帧
    ///
    /// # 示例
    /// ```
    /// let addr = PhysAddr::new(0x8020_1234);
    /// let frame = PhysFrame::from_addr(addr);
    /// // frame 对应的地址是 0x8020_1000
    /// ```
    pub fn from_addr(addr: PhysAddr) -> Self {
        Self {
            number: addr.page_number(),
        }
    }

    /// 获取页帧号
    pub const fn number(&self) -> usize {
        self.number
    }

    /// 获取页帧的起始物理地址
    ///
    /// # 返回
    /// 页帧起始地址（页帧号 × 4096）
    pub const fn start_address(&self) -> PhysAddr {
        PhysAddr::new(self.number * PAGE_SIZE)
    }

    /// 获取页帧的结束物理地址
    ///
    /// # 返回
    /// 页帧结束地址（页帧号 × 4096 + 4095）
    pub const fn end_address(&self) -> PhysAddr {
        PhysAddr::new(self.number * PAGE_SIZE + PAGE_SIZE - 1)
    }
}

impl fmt::Debug for PhysFrame {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PhysFrame(#{}, {:#x}..{:#x})",
            self.number,
            self.start_address().as_usize(),
            self.end_address().as_usize()
        )
    }
}
```

---

#### 实现页帧范围类型

为了方便地表示一段连续的页帧，我们实现一个范围类型。

**定义 PhysFrameRange**

```rust
/// 物理页帧范围
///
/// # 说明
/// 表示一段连续的物理页帧 [start, end)
/// 左闭右开区间
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct PhysFrameRange {
    pub start: PhysFrame,
    pub end: PhysFrame,
}

impl PhysFrameRange {
    /// 创建新的页帧范围
    ///
    /// # 参数
    /// - `start`: 起始页帧
    /// - `end`: 结束页帧（不包含）
    ///
    /// # 返回
    /// PhysFrameRange 实例
    pub const fn new(start: PhysFrame, end: PhysFrame) -> Self {
        Self { start, end }
    }

    /// 检查范围是否为空
    pub const fn is_empty(&self) -> bool {
        self.start.number >= self.end.number
    }

    /// 获取范围内的页帧数量
    pub const fn len(&self) -> usize {
        if self.start.number >= self.end.number {
            0
        } else {
            self.end.number - self.start.number
        }
    }
}

impl fmt::Debug for PhysFrameRange {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PhysFrameRange({}..{}, {} frames)",
            self.start.number,
            self.end.number,
            self.len()
        )
    }
}
```

---

#### 实现页帧迭代器

为了方便遍历页帧范围，我们实现 `Iterator` trait。

**实现迭代器**

```rust
impl Iterator for PhysFrameRange {
    type Item = PhysFrame;

    fn next(&mut self) -> Option<Self::Item> {
        if self.start.number < self.end.number {
            let frame = self.start;
            self.start = PhysFrame::from_number(self.start.number + 1);
            Some(frame)
        } else {
            None
        }
    }
}
```

**测试页帧类型**

在 `os/src/memory.rs` 中添加测试函数：

```rust
/// 测试物理页帧
pub fn test_phys_frame() {
    use crate::println;

    println!("\n========================================");
    println!("  测试 PhysFrame");
    println!("========================================\n");

    // 测试 1：创建页帧
    println!("[TEST 1] 创建页帧");
    let frame = PhysFrame::from_number(0x80201);
    println!("  页帧: {:?}", frame);
    println!("  起始地址: {}", frame.start_address());
    println!("  结束地址: {}", frame.end_address());

    // 测试 2：从地址创建
    println!("\n[TEST 2] 从地址创建页帧");
    let addr = PhysAddr::new(0x80201234);
    let frame = PhysFrame::from_addr(addr);
    println!("  物理地址: {}", addr);
    println!("  所属页帧: {:?}", frame);

    // 测试 3：页帧范围
    println!("\n[TEST 3] 页帧范围");
    let start = PhysFrame::from_number(100);
    let end = PhysFrame::from_number(105);
    let range = PhysFrameRange::new(start, end);
    println!("  范围: {:?}", range);
    println!("  包含页帧数: {}", range.len());

    // 测试 4：遍历页帧
    println!("\n[TEST 4] 遍历页帧");
    let start = PhysFrame::from_number(0x80200);
    let end = PhysFrame::from_number(0x80203);
    let mut range = PhysFrameRange::new(start, end);
    println!("  遍历 {:?}:", range);
    let mut count = 0;
    for frame in range {
        println!("    页帧 #{}: {}", count, frame.start_address());
        count += 1;
        if count >= 3 {  // 只打印前 3 个
            break;
        }
    }

    println!("\n========================================\n");
}
```

**在 main.rs 中调用**

```rust
#[no_mangle]
pub extern "C" fn kernel_main() -> ! {
    println!("Welcome to Error OS!");
    os::init();

    os::memory::print_memory_layout();
    os::memory::test_phys_addr();
    os::memory::test_phys_frame();  // 添加这行

    os::hlt_loop();
}
```

**编译并运行，预期输出**

```
========================================
  测试 PhysFrame
========================================

[TEST 1] 创建页帧
  页帧: PhysFrame(#524801, 0x80201000..0x80201fff)
  起始地址: 0x80201000
  结束地址: 0x80201fff

[TEST 2] 从地址创建页帧
  物理地址: 0x80201234
  所属页帧: PhysFrame(#524801, 0x80201000..0x80201fff)

[TEST 3] 页帧范围
  范围: PhysFrameRange(100..105, 5 frames)
  包含页帧数: 5

[TEST 4] 遍历页帧
  遍历 PhysFrameRange(524800..524803, 3 frames):
    页帧 #0: 0x80200000
    页帧 #1: 0x80201000
    页帧 #2: 0x80202000

========================================
```

 输出正确说明页帧类型实现成功

