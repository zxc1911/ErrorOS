# ERROR OS 完整章节结构

**最后更新**: 2025年11月24日
**版本**: v1.0

---

## 第一部分：基础篇

### 第0章：环境搭建与工具链

#### 0.1 Rust 工具链安装
- 0.1.1 安装 Rust nightly
- 0.1.2 配置 rustup 组件
- 0.1.3 添加 RISC-V 目标支持

#### 0.2 QEMU 模拟器配置
- 0.2.1 安装 QEMU RISC-V 版本
- 0.2.2 验证 QEMU 功能
- 0.2.3 配置 QEMU 启动脚本

#### 0.3 项目结构初始化
- 0.3.1 创建 Cargo 工作空间
- 0.3.2 配置编译目标
- 0.3.3 编写链接器脚本 (linker.ld)

#### 0.4 开发工具配置
- 0.4.1 配置 VSCode 开发环境
- 0.4.2 设置 GDB 调试工具
- 0.4.3 配置代码格式化工具

---

### 第1章：启动流程与串口输出

#### 1.1 去除标准库依赖
- 1.1.1 添加 `#![no_std]` 声明
- 1.1.2 添加 `#![no_main]` 声明
- 1.1.3 实现自定义 panic handler
- 1.1.4 配置 panic = "abort"

#### 1.2 实现最小内核程序
- 1.2.1 编写 RISC-V 汇编入口点 (`_start`)
- 1.2.2 实现 BSS 段清零
- 1.2.3 初始化栈指针
- 1.2.4 跳转到 Rust `kernel_main`

#### 1.3 UART 串口驱动实现
- 1.3.1 理解 UART 16550 寄存器
- 1.3.2 封装 UART 驱动接口
- 1.3.3 实现字节级输出
- 1.3.4 实现格式化输出支持

#### 1.4 实现输出宏
- 1.4.1 实现 `serial_print!` 宏
- 1.4.2 实现 `serial_println!` 宏
- 1.4.3 实现 `print!` 宏（控制台）
- 1.4.4 实现 `println!` 宏（控制台）
- 1.4.5 实现 `core::fmt::Write` trait

#### 1.5 第一个内核输出
- 1.5.1 在 `kernel_main` 中输出欢迎信息
- 1.5.2 验证 QEMU 中的输出
- 1.5.3 测试不同格式的输出

---

### 第2章：中断系统

#### 2.1 RISC-V 特权级架构
- 2.1.1 理解 M/S/U 三种特权级
- 2.1.2 理解异常和中断的区别
- 2.1.3 学习 CSR 寄存器

#### 2.2 异常处理机制
- 2.2.1 理解 stvec 寄存器（异常向量表）
- 2.2.2 理解 scause 寄存器（异常原因）
- 2.2.3 理解 sepc 寄存器（异常返回地址）
- 2.2.4 理解 stval 寄存器（异常相关值）
- 2.2.5 理解 sstatus 寄存器（状态寄存器）

#### 2.3 中断描述符表 (IDT)
- 2.3.1 设计异常处理函数注册机制
- 2.3.2 配置 stvec 寄存器
- 2.3.3 选择 Direct 模式 vs Vectored 模式

#### 2.4 异常处理入口（汇编）
- 2.4.1 保存所有通用寄存器
- 2.4.2 保存浮点寄存器（可选）
- 2.4.3 调用 Rust 异常处理函数
- 2.4.4 恢复寄存器上下文
- 2.4.5 使用 sret 返回

#### 2.5 异常分发器
- 2.5.1 根据 scause 分发异常
- 2.5.2 实现断点异常处理 (ebreak)
- 2.5.3 实现非法指令异常处理
- 2.5.4 实现系统调用异常处理 (ecall)
- 2.5.5 实现页面错误处理（占位）

#### 2.6 中断使能与屏蔽
- 2.6.1 配置 sie 寄存器（中断使能）
- 2.6.2 配置 sip 寄存器（中断挂起）
- 2.6.3 全局中断开关

#### 2.7 测试异常处理
- 2.7.1 测试断点异常
- 2.7.2 测试非法指令异常
- 2.7.3 验证异常返回机制

---

### 第3章：物理内存管理

#### 3.1 物理内存布局
- 3.1.1 理解 RISC-V QEMU 内存映射
- 3.1.2 定义内核代码段布局
- 3.1.3 定义内核数据段布局
- 3.1.4 定义 BSS 段布局
- 3.1.5 通过链接器脚本控制布局

#### 3.2 物理地址和虚拟地址抽象
- 3.2.1 定义 `PhysAddr` 类型
- 3.2.2 定义 `VirtAddr` 类型
- 3.2.3 实现地址对齐检查
- 3.2.4 实现地址转换接口

#### 3.3 物理页帧定义
- 3.3.1 定义 4KB 页帧大小
- 3.3.2 实现 `PhysFrame` 结构体
- 3.3.3 实现页帧迭代器
- 3.3.4 实现页帧范围类型

#### 3.4 物理页帧分配器
- 3.4.1 设计分配器接口
- 3.4.2 实现 Bump Allocator（简单版）
- 3.4.3 实现 `allocate()` 方法
- 3.4.4 实现 `deallocate()` 方法
- 3.4.5 实现空闲内存统计

#### 3.5 堆分配器
- 3.5.1 定义堆内存区域
- 3.5.2 选择堆分配器实现
- 3.5.3 实现全局分配器接口
- 3.5.4 初始化堆分配器

#### 3.6 堆分配器实现（三种策略）
- 3.6.1 Bump Allocator（最简单）
- 3.6.2 Linked List Allocator（常用）
- 3.6.3 Fixed Size Block Allocator（高性能）
- 3.6.4 对比三种分配器性能

#### 3.7 测试动态内存分配
- 3.7.1 测试 `Box<T>` 分配
- 3.7.2 测试 `Vec<T>` 动态数组
- 3.7.3 测试 `Rc<T>` 引用计数
- 3.7.4 测试内存分配失败处理

---

## 第二部分：核心篇（重点）

### 第4章：虚拟内存管理

#### 4.1 虚拟地址解析
- 4.1.1 理解 Sv39 页表机制
- 4.1.2 实现 VirtAddr 类型
- 4.1.3 实现 VPN 提取函数
- 4.1.4 实现页内偏移提取
- 4.1.5 可视化展示虚拟地址结构

#### 4.2 页表遍历
- 4.2.1 定义页表项 (PTE) 结构
- 4.2.2 定义页表标志位 (V, R, W, X, U)
- 4.2.3 实现单级页表查找
- 4.2.4 实现三级页表遍历
- 4.2.5 实现 `walk_page_table` 函数
- 4.2.6 实现 `walk_page_table_verbose` 可视化版本

#### 4.3 页面映射
- 4.3.1 实现 `map_page` 函数
- 4.3.2 实现中间页表自动分配
- 4.3.3 设置页表项标志位
- 4.3.4 实现 `map_page_verbose` 可视化版本
- 4.3.5 实现 `unmap_page` 函数

#### 4.4 地址空间抽象
- 4.4.1 设计 `AddressSpace` 结构体
- 4.4.2 设计 `MemoryArea` 结构体
- 4.4.3 实现地址空间创建
- 4.4.4 实现地址空间销毁
- 4.4.5 实现区域映射管理
- 4.4.6 实现地址空间布局打印

#### 4.5 内核地址空间
- 4.5.1 创建内核地址空间
- 4.5.2 映射内核代码段
- 4.5.3 映射内核数据段
- 4.5.4 映射 UART 设备
- 4.5.5 激活地址空间（切换页表）

---

### 第5章：系统调用

#### 5.1 系统调用机制
- 5.1.1 理解 ecall 指令
- 5.1.2 定义系统调用号（Linux 兼容）
- 5.1.3 理解 RISC-V 调用约定
- 5.1.4 设计系统调用返回值机制

#### 5.2 系统调用上下文
- 5.2.1 定义 `SyscallContext` 结构体
- 5.2.2 实现从寄存器读取参数
- 5.2.3 实现设置返回值到 a0
- 5.2.4 保存系统调用发生时的 PC

#### 5.3 系统调用分发器
- 5.3.1 实现系统调用号识别
- 5.3.2 根据系统调用号分发
- 5.3.3 实现可视化追踪输出（verbose 模式）
- 5.3.4 实现错误处理（无效系统调用）

#### 5.4 基础系统调用实现
- 5.4.1 实现 sys_write（写入数据）
  - 参数验证（文件描述符、指针）
  - 支持 stdout (fd=1) 和 stderr (fd=2)
  - UTF-8 字符串处理
  - 返回写入字节数
- 5.4.2 实现 sys_exit（退出进程）
  - 接收退出码
  - 打印退出信息
  - 进入死循环（简化实现）
- 5.4.3 实现 sys_getpid（获取进程ID）
  - 返回当前进程 PID
  - 简化实现（返回固定值1）

#### 5.5 系统调用可视化追踪
- 5.5.1 设计可视化输出格式
- 5.5.2 实现 Feature flag 控制
- 5.5.3 美观的表格输出
- 5.5.4 显示所有参数和返回值
- 5.5.5 支持运行时开关

#### 5.6 系统调用测试
- 5.6.1 测试 sys_getpid
- 5.6.2 测试 sys_write
- 5.6.3 测试无效系统调用
- 5.6.4 验证错误处理

---

### 第6章：进程管理

#### 6.1 进程控制块 (PCB)
- 6.1.1 设计 `Process` 结构体
  - 进程 ID (PID)
  - 进程状态
  - 父进程指针
  - 子进程列表
  - 退出码
- 6.1.2 实现 PID 分配器
- 6.1.3 定义进程状态枚举
  - Running（运行）
  - Ready（就绪）
  - Blocked（阻塞）
  - Zombie（僵尸）
- 6.1.4 实现进程上下文保存
- 6.1.5 实现进程创建和销毁

#### 6.2 上下文切换
- 6.2.1 设计上下文结构体
  - 通用寄存器 (x0-x31)
  - PC 寄存器
  - 浮点寄存器（可选）
  - CSR 寄存器
- 6.2.2 实现保存寄存器上下文（汇编）
- 6.2.3 实现恢复寄存器上下文（汇编）
- 6.2.4 实现切换页表 (satp 寄存器)
- 6.2.5 实现 `switch_context` 函数
- 6.2.6 可视化上下文切换过程

#### 6.3 进程调度
- 6.3.1 设计调度器接口
- 6.3.2 实现简单轮转调度（Round-Robin）
- 6.3.3 实现进程就绪队列
- 6.3.4 实现时间片机制
  - 配置定时器中断
  - 时间片耗尽处理
  - 时间片重置
- 6.3.5 实现进程选择算法
- 6.3.6 可视化调度过程

#### 6.4 进程生命周期
- 6.4.1 实现进程创建（fork）
  - 复制父进程地址空间
  - 复制进程控制块
  - 设置子进程返回值
  - 可视化 fork 过程
- 6.4.2 实现进程执行（exec）
  - 加载 ELF 文件（简化版）
  - 创建新的地址空间
  - 设置入口点
  - 可视化 exec 过程
- 6.4.3 实现进程退出（exit）
  - 释放进程资源
  - 通知父进程
  - 转为僵尸状态
  - 可视化退出过程
- 6.4.4 实现进程等待（wait）
  - 等待子进程退出
  - 回收僵尸进程
  - 返回退出码
  - 可视化等待过程
- 6.4.5 僵尸进程处理
  - 理解僵尸进程产生原因
  - 实现僵尸进程回收
  - 防止僵尸进程泄漏

---

### 第7章：文件系统

#### 7.1 虚拟文件系统接口 (VFS)
- 7.1.1 设计文件抽象（File trait）
  - read() 方法
  - write() 方法
  - seek() 方法
  - stat() 方法
- 7.1.2 设计 Inode 抽象
  - 文件元数据
  - 文件类型（普通文件、目录、设备）
  - 权限位
  - 时间戳
- 7.1.3 实现文件描述符管理
  - 文件描述符表
  - 分配文件描述符
  - 释放文件描述符
- 7.1.4 实现 open/read/write/close 接口
- 7.1.5 实现标准输入输出文件
  - stdin (fd=0)
  - stdout (fd=1)
  - stderr (fd=2)

#### 7.2 简单文件系统实现（RamFS）
- 7.2.1 设计内存文件系统结构
  - 文件存储在内存中
  - 简单的目录树结构
- 7.2.2 实现目录结构
  - 根目录
  - 目录项（DirEntry）
  - 目录遍历
- 7.2.3 实现文件创建和删除
- 7.2.4 实现文件读写
  - 顺序读写
  - 随机访问
- 7.2.5 实现文件元数据管理
  - 文件大小
  - 创建时间
  - 修改时间
- 7.2.6 可视化文件系统操作

#### 7.3 文件系统系统调用
- 7.3.1 实现 sys_open
- 7.3.2 实现 sys_read
- 7.3.3 实现 sys_write（完善版）
- 7.3.4 实现 sys_close
- 7.3.5 实现 sys_mkdir
- 7.3.6 实现 sys_chdir
- 7.3.7 实现 sys_stat

#### 7.4 文件系统测试
- 7.4.1 测试文件创建和删除
- 7.4.2 测试文件读写
- 7.4.3 测试目录操作
- 7.4.4 测试文件描述符管理

---

## 第三部分：进阶篇

### 第8章：用户程序与 ELF 加载

#### 8.1 ELF 文件格式
- 8.1.1 理解 ELF 文件结构
  - ELF Header
  - Program Header
  - Section Header
- 8.1.2 理解程序段（Segment）
  - .text 段（代码）
  - .data 段（数据）
  - .bss 段（未初始化数据）
  - .rodata 段（只读数据）
- 8.1.3 理解程序入口点

#### 8.2 ELF 文件解析
- 8.2.1 实现 ELF Header 解析
- 8.2.2 实现 Program Header 解析
- 8.2.3 验证 ELF 文件合法性
- 8.2.4 提取程序段信息

#### 8.3 程序加载器
- 8.3.1 创建用户地址空间
- 8.3.2 加载程序段到内存
- 8.3.3 设置段权限（R/W/X）
- 8.3.4 初始化用户栈
- 8.3.5 设置程序入口点

#### 8.4 用户态程序运行
- 8.4.1 切换到用户态
- 8.4.2 设置用户态页表
- 8.4.3 跳转到用户程序入口
- 8.4.4 处理用户态异常

#### 8.5 用户空间内存布局
- 8.5.1 设计用户地址空间布局
  - 代码段地址
  - 数据段地址
  - 堆地址
  - 栈地址
- 8.5.2 实现堆增长（brk/sbrk）
- 8.5.3 实现栈增长
- 8.5.4 可视化用户内存布局

#### 8.6 用户程序示例
- 8.6.1 编写简单的用户程序（C）
- 8.6.2 编译为 RISC-V ELF
- 8.6.3 测试加载和运行
- 8.6.4 测试系统调用

---

### 第9章：Shell 实现

#### 9.1 Shell 基础架构
- 9.1.1 设计 Shell 主循环
- 9.1.2 实现命令行读取
- 9.1.3 实现命令提示符
- 9.1.4 实现基本错误处理

#### 9.2 命令解析
- 9.2.1 实现命令行分词（tokenize）
- 9.2.2 实现命令解析
- 9.2.3 处理引号和转义
- 9.2.4 处理环境变量展开

#### 9.3 内置命令实现
- 9.3.1 实现 `echo` 命令
- 9.3.2 实现 `cd` 命令
- 9.3.3 实现 `pwd` 命令
- 9.3.4 实现 `ls` 命令
- 9.3.5 实现 `cat` 命令
- 9.3.6 实现 `exit` 命令
- 9.3.7 实现 `help` 命令

#### 9.4 外部程序执行
- 9.4.1 实现程序查找（PATH）
- 9.4.2 使用 fork + exec 执行程序
- 9.4.3 等待程序执行完成
- 9.4.4 获取程序退出码

#### 9.5 I/O 重定向（可选）
- 9.5.1 实现输出重定向（>）
- 9.5.2 实现输入重定向（<）
- 9.5.3 实现追加重定向（>>）
- 9.5.4 实现错误重定向（2>）

#### 9.6 管道实现（可选）
- 9.6.1 理解管道机制
- 9.6.2 实现管道系统调用（pipe）
- 9.6.3 实现管道符号（|）解析
- 9.6.4 连接多个进程

#### 9.7 Shell 测试
- 9.7.1 测试基本命令
- 9.7.2 测试程序执行
- 9.7.3 测试 I/O 重定向
- 9.7.4 测试管道

---

### 第10章：性能优化与调试技巧

#### 10.1 性能分析工具
- 10.1.1 实现简单的性能计数器
- 10.1.2 测量系统调用开销
- 10.1.3 测量上下文切换开销
- 10.1.4 测量内存分配性能

#### 10.2 内存优化
- 10.2.1 减少内存碎片
- 10.2.2 优化页帧分配器
- 10.2.3 实现内存缓存（Cache）
- 10.2.4 检测内存泄漏

#### 10.3 代码优化
- 10.3.1 热点代码分析
- 10.3.2 减少不必要的分配
- 10.3.3 使用内联函数
- 10.3.4 优化编译选项

#### 10.4 调试技巧
- 10.4.1 使用 GDB 调试内核
- 10.4.2 使用 QEMU 调试功能
- 10.4.3 添加调试断言
- 10.4.4 实现内核日志系统

#### 10.5 常见错误诊断
- 10.5.1 页面错误（Page Fault）
  - 地址未映射
  - 权限不足
  - 页表损坏
- 10.5.2 非法指令
  - 代码损坏
  - 跳转错误
  - 对齐问题
- 10.5.3 系统调用错误
  - 参数验证失败
  - 权限检查失败
  - 资源不足
- 10.5.4 死锁和竞态条件
  - 自旋锁使用不当
  - 中断处理中的问题

#### 10.6 测试策略
- 10.6.1 单元测试
- 10.6.2 集成测试
- 10.6.3 压力测试
- 10.6.4 回归测试

---

## 附录

### 附录A：RISC-V 指令速查

#### A.1 基本指令
- A.1.1 算术指令（add, sub, mul, div）
- A.1.2 逻辑指令（and, or, xor）
- A.1.3 移位指令（sll, srl, sra）
- A.1.4 比较指令（slt, sltu）

#### A.2 内存访问指令
- A.2.1 加载指令（lb, lh, lw, ld）
- A.2.2 存储指令（sb, sh, sw, sd）
- A.2.3 原子指令（lr, sc）

#### A.3 控制转移指令
- A.3.1 分支指令（beq, bne, blt, bge）
- A.3.2 跳转指令（jal, jalr）

#### A.4 特权指令
- A.4.1 系统调用（ecall, ebreak）
- A.4.2 异常返回（sret, mret）
- A.4.3 CSR 指令（csrrw, csrrs, csrrc）

#### A.5 CSR 寄存器表
- A.5.1 机器模式 CSR（M-mode）
- A.5.2 监管模式 CSR（S-mode）
- A.5.3 用户模式 CSR（U-mode）

---

### 附录B：常见错误与解决方案

#### B.1 编译错误
- B.1.1 链接器错误
- B.1.2 类型错误
- B.1.3 生命周期错误

#### B.2 运行时错误
- B.2.1 页面错误
- B.2.2 系统调用错误
- B.2.3 进程切换错误
- B.2.4 文件系统错误

#### B.3 性能问题
- B.3.1 内存泄漏
- B.3.2 死锁
- B.3.3 性能瓶颈

---

### 附录C：实验环境配置

#### C.1 Rust 工具链
- C.1.1 安装步骤
- C.1.2 常见问题
- C.1.3 版本要求

#### C.2 QEMU 配置
- C.2.1 安装步骤
- C.2.2 启动参数说明
- C.2.3 调试配置

#### C.3 GDB 调试配置
- C.3.1 连接到 QEMU
- C.3.2 常用调试命令
- C.3.3 调试脚本

#### C.4 VSCode 集成
- C.4.1 插件安装
- C.4.2 任务配置
- C.4.3 调试配置

---

### 附录D：参考资源

#### D.1 官方文档
- D.1.1 RISC-V 指令集手册
- D.1.2 RISC-V 特权级架构手册
- D.1.3 RISC-V SBI 规范

#### D.2 开源项目
- D.2.1 rCore-Tutorial
- D.2.2 xv6-riscv
- D.2.3 Linux Kernel

#### D.3 推荐书籍
- D.3.1 《Operating Systems: Three Easy Pieces》
- D.3.2 《Computer Systems: A Programmer's Perspective》
- D.3.3 《The RISC-V Reader》

#### D.4 在线资源
- D.4.1 RISC-V 官网
- D.4.2 Rust 官方文档
- D.4.3 OS 开发论坛

---

**文档说明**：

本文档提供了 ERROR OS 项目的完整章节结构。每个章节都细分为多个小节，确保学习者可以循序渐进地掌握操作系统开发的各个方面。

**章节特点**：
- ✅ 渐进式学习路径
- ✅ 每个小节独立可测试
- ✅ 完整的理论到实践覆盖
- ✅ 丰富的可视化教学内容

**使用建议**：
- 按顺序学习基础篇和核心篇
- 进阶篇可根据兴趣选择
- 遇到问题参考附录部分
- 每完成一个小节进行测试验证

---

**版本历史**：
- v1.0 (2025-11-24): 初始版本，完整章节结构
