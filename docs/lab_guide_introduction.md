# ERROR OS 实验指导书

## 引言：为什么是 ERROR OS？

### 名字的由来

相信大家都很疑惑，“Error”是一个程序员避之不及的状态，为什么我们会选用它作为我们操作系统的名称？这并非是我们一时兴起随意为之，而是我们认真的选择

**ERROR** 这个名字有三重含义：

1. **Error-Driven Learning（错误驱动学习）**

   在操作系统学习中，错误不是障碍，而是最好的老师。每一个page fault、每一次段错误、每一个调试过程，都是深入理解系统的机会。ERROR OS 拥抱错误，让你在可控的环境中犯错、理解错误、从错误中学习。

2. **Error Reporting & Reasoning OS（错误报告与推理操作系统）**

   传统OS出错时，你只能看到：
   ```
   Segmentation fault (core dumped)
   ```

   我们期望ERROR OS 出错时，你会看到：
   ```
   ╔════════════════════════════════════════╗
   ║ 页面访问错误                           ║
   ╠════════════════════════════════════════╣
   ║ 虚拟地址: 0x0000000010001000           ║
   ║ 访问类型: 读取                         ║
   ║ 当前进程: PID=2 (shell)               ║
   ╠════════════════════════════════════════╣
   ║ 错误原因分析:                         ║
   ║ [×] 该页未映射到物理内存              ║
   ║ [✓] 页表根地址有效                    ║
   ║ [✓] VPN[2] 查找成功                   ║
   ║ [×] VPN[1] 对应页表项无效             ║
   ╠════════════════════════════════════════╣
   ║ 可能的解决方案:                       ║
   ║ 1. 检查是否调用了 mmap               ║
   ║ 2. 确认地址在进程地址空间内          ║
   ║ 3. 查看页表映射关系                  ║
   ╚════════════════════════════════════════╝
   ```

   详细的错误报告和推理过程，帮助你快速定位问题、理解原因。

3. **Explicit, Readable, Reflective OS（明确、可读、可反思的操作系统）**

   - **Explicit（明确）**：每个操作都有清晰的输出，不隐藏任何细节
   - **Readable（可读）**：代码注释详尽，变量命名语义化，逻辑流程清晰
   - **Reflective（可反思）**：系统能"自省"，随时展示内部状态

---

## 我们解决什么痛点？

### 痛点1：理论课与实践的鸿沟

**场景还原**：
```
理论课老师："虚拟地址通过三级页表转换为物理地址，
             VPN[2]索引一级页表，VPN[1]索引二级页表..."

你的大脑：这些数字是怎么算出来的？计算机内部怎么执行的？

传统实验：给你一个完整的页表实现（500行代码），
         "理解它，然后完成XXX功能"

这就不得不提到一个经典的程序员笑话：
It doesn't work why?
It works why?
```

**ERROR OS 的解决方案**：

```rust
// 第1步：理解虚拟地址结构（30行代码）
fn decompose_virtual_address(vaddr: VirtAddr) {
    let vpn2 = (vaddr >> 30) & 0x1FF;  // bits 38-30
    let vpn1 = (vaddr >> 21) & 0x1FF;  // bits 29-21
    let vpn0 = (vaddr >> 12) & 0x1FF;  // bits 20-12
    let offset = vaddr & 0xFFF;        // bits 11-0

    serial_println!("虚拟地址分解:");
    serial_println!("  VPN[2] = {} (索引一级页表)", vpn2);
    serial_println!("  VPN[1] = {} (索引二级页表)", vpn1);
    serial_println!("  VPN[0] = {} (索引三级页表)", vpn0);
    serial_println!("  Offset = {:#x} (页内偏移)", offset);
}

//  运行测试，看到输出，理解原理
//  然后再进入第2步...
```

**对比数据**：
| 维度 | 传统方式 | ERROR OS |
|------|---------|----------|
| 首次接触代码量 | 500-1200行 | 30-80行/步 |
| 能否独立测试 | ❌ 需要完整系统 | ✅ 每步独立运行 |
| 理解所需时间 | 8-12小时 | 3-5小时（分步骤） |
| 错误定位难度 | 高（全局调试） | 低（步骤隔离） |

---

### 痛点2：运行过程的"黑盒"

**场景还原**：
```
你写完页表遍历代码，编译通过，运行...

传统OS：
[Kernel] Memory subsystem initialized
[Kernel] Virtual memory enabled
[Kernel] Ready.

你：真的对了吗？页表到底查了几次？
   我的代码真的执行了吗？还是巧合？
```

**ERROR OS 的解决方案**：

```
ERROR OS（verbose模式）：
╔════════════════════════════════════════╗
║     页表遍历过程（Sv39）              ║
╠════════════════════════════════════════╣
║ 虚拟地址: 0x0000000010000000           ║
║ 根页表:   0x00000000804c3000           ║
╚════════════════════════════════════════╝

[1] 虚拟地址分解:
    VPN[2] =   0 (bits 38-30)  ← 这个数字怎么来的？看上面的代码！
    VPN[1] = 128 (bits 29-21)  ← 0x10000000 >> 21 & 0x1FF = 128
    VPN[0] =   0 (bits 20-12)
    Offset = 0x000 (bits 11-0)

[2] Level 2 查找 (VPN[2] = 0):
    页表基址: 0x804c3000
    页表项地址 = 0x804c3000 + 0 * 8 = 0x804c3000
    读取页表项: 0x00000000201310c1
    ✓ 页表项有效 (V=1)
    ✓ 非叶子节点 (R=0, W=0, X=0)
    PPN = 0x804c4
    → 下一级页表地址: 0x804c4000

[3] Level 1 查找 (VPN[1] = 128):
    页表基址: 0x804c4000
    页表项地址 = 0x804c4000 + 128 * 8 = 0x804c4400
    读取页表项: 0x00000000201314c1
    ✓ 页表项有效 (V=1)
    ✓ 非叶子节点 (R=0, W=0, X=0)
    PPN = 0x804c5
    → 下一级页表地址: 0x804c5000

[4] Level 0 查找 (VPN[0] = 0):
    页表基址: 0x804c5000
    页表项地址 = 0x804c5000 + 0 * 8 = 0x804c5000
    读取页表项: 0x00000000204004cf
    ✓ 页表项有效 (V=1)
    ✓ 叶子节点 (R=1, W=1, X=0) - 数据页
    PPN = 0x81000

✓ 转换完成: 0x10000000 → 0x81000000
  物理地址 = PPN << 12 | Offset
           = 0x81000 << 12 | 0x000
           = 0x81000000

你： 原来是这样
```

**关键差异**：
- 不只是"结果对了"，而是"过程对了"
- 不只是"能运行"，而是"理解为什么能运行"
- 不只是"通过测试"，而是"掌握原理"

---

### 痛点3：跨度过大的实验步骤

**典型问题**：

很多OS实验教程的结构：
```
第1章：Hello World（50行） 简单，学会了
第2章：中断处理（200行）    有点难，但能跟上
第3章：内存管理（300行）    多看几遍，理解了
第4章：虚拟内存（1200行）   ？？？
       ↓
    我的操作系统生涯之从入门到放弃
```

**实测数据**：
- rCore 第4章新增代码：约1200行
- 涉及概念：页表、地址空间、内存集合、跳板页、内核栈等
- 学生反馈："看懂了文档，但不知道从哪开始写"

**ERROR OS 的解决方案**：

将大章节拆分为**小步骤，渐进式推进**：

```
虚拟内存模块（ERROR OS分步实现）：

Step 1: 虚拟地址解析（1小时）
├─ 代码量：80行
├─ 核心概念：VPN分解、页内偏移
└─ 测试：输入地址，查看分解结果

Step 2: 单级页表查找（1小时）
├─ 代码量：100行
├─ 核心概念：页表项格式、PPN提取
└─ 测试：给定页表，查找一个VPN

Step 3: 三级页表遍历（1.5小时）
├─ 代码量：150行
├─ 核心概念：递归查找、叶子判断
└─ 测试：完整地址转换

Step 4: 页面映射基础（1.5小时）
├─ 代码量：120行
├─ 核心概念：页表项写入、标志位
└─ 测试：映射单个页面

Step 5: 多级页表创建（1.5小时）
├─ 代码量：150行
├─ 核心概念：中间页表分配
└─ 测试：映射需要创建中间表的地址

Step 6: 地址空间抽象（1.5小时）
├─ 代码量：180行
├─ 核心概念：地址空间、内存区域
└─ 测试：创建完整地址空间

Step 7: 内核地址空间（1小时）
├─ 代码量：100行
├─ 核心概念：恒等映射、内核空间
└─ 测试：激活虚拟内存

Step 8: 综合测试与优化（1小时）
├─ 代码量：100行
├─ 核心概念：TLB刷新、性能优化
└─ 测试：完整功能验证

总计：约10小时，800行代码，8个独立步骤
```

**学习曲线对比**：

```
传统方式的学习曲线：
理解度
  100% |
       |
   75% |        ╱────       需要一次性理解全部
       |       /
   50% |      /
       |     /
   25% |____/               前期陡峭，容易放弃
       |
     0% └────────────────── 时间
        0h  2h  4h  6h  8h

ERROR OS的学习曲线：
理解度
  100% |            ╱──╱──╱   每步都能完全理解
       |          ╱  ╱  ╱
   75% |        ╱  ╱  ╱
       |      ╱  ╱  ╱
   50% |    ╱  ╱  ╱
       |  ╱  ╱  ╱
   25% |╱  ╱  ╱               平缓上升，持续进步
       |
     0% └────────────────── 时间
        0h  2h  4h  6h  8h  10h
```

---

### 痛点4：调试困难，错误难定位

**典型场景**：

```
你在虚拟内存实验中遇到了错误：

传统OS的反馈：
QEMU: exception 0xd (page fault)
sepc: 0x80200abc
stval: 0x10001000
Kernel panic!

你： 哪里错了？
    - 是地址没映射？
    - 是页表项写错了？
    - 是权限位不对？
    - 还是其他问题？

    → 花2小时用GDB单步调试
    → 打印一堆日志
    → 最后发现：忘记设置V位（有效位）
```

**ERROR OS 的反馈**：

```
╔════════════════════════════════════════╗
║        页面访问错误 (Page Fault)         ║
╠════════════════════════════════════════╣
║ 错误位置: sepc = 0x80200abc            ║
║ 访问地址: stval = 0x10001000           ║
║ 指令类型: Load (读取)                  ║
╠════════════════════════════════════════╣
║ 🔍 错误诊断:                          ║
╠════════════════════════════════════════╣
║ [✓] 地址在有效范围内                  ║
║ [✓] 页表根地址正确                    ║
║ [✓] VPN[2] 查找成功                   ║
║ [✓] VPN[1] 查找成功                   ║
║ [×] VPN[0] 页表项无效                 ║
║                                        ║
║ 详细信息:                             ║
║   Level 0 页表项地址: 0x804c5000      ║
║   读取到的值: 0x000000002040044e      ║
║   问题: V位=0 (页表项未标记为有效)    ║
╠════════════════════════════════════════╣
║ 💡 可能的原因:                        ║
║ 1. 调用 map_page 时忘记设置 PTE_V    ║
║ 2. 页表项被错误清零                   ║
║ 3. 使用了错误的页表基址               ║
╠════════════════════════════════════════╣
║ 🔧 建议的解决方案:                    ║
║ 1. 检查 map_page 的 flags 参数        ║
║    确保包含: PTE_V | PTE_R | PTE_W   ║
║ 2. 使用 walk_page_table_verbose()    ║
║    查看完整的页表遍历过程             ║
║ 3. 检查相关代码位置:                 ║
║    os/src/memory/paging.rs:142       ║
╚════════════════════════════════════════╝

你：原来是忘记设置V位了，5分钟修好！
```

**调试效率对比**：

| 错误类型 | 传统OS定位时间 | ERROR OS定位时间 | 效率提升 |
|---------|---------------|-----------------|----------|
| 页表配置错误 | 1-2小时 | 5-10分钟 | **10倍** |
| 权限位错误 | 30-60分钟 | 2-5分钟 | **10倍** |
| 地址计算错误 | 1-3小时 | 10-15分钟 | **8倍** |
| 系统调用参数错误 | 30分钟 | 3-5分钟 | **8倍** |

---

## ERROR OS 的设计哲学

### 1. 过程可见（Process Visibility）

> **"如果看不见过程，就无法真正理解。"**

在ERROR OS中，一切重要操作都有详细的过程展示：
- 页表遍历：看见每一级的查找
- 进程切换：看见寄存器的保存与恢复
- 系统调用：看见用户态到内核态的转换
- 内存分配：看见物理帧的分配与回收

### 2. 渐进式学习（Progressive Learning）

> **"不积跬步，无以至千里。"**

将复杂功能分解为小步骤：
- 每步代码量控制在 50-150 行
- 每步聚焦一个核心概念
- 每步都能独立测试验证
- 先理解原理，再看完整实现

### 3. 错误即教材（Error as Teacher）

> **"每个错误都是深入理解的机会。"**

详细的错误诊断：
- 不只报告"出错了"，还说明"为什么出错"
- 不只给出错误码，还提供可能的原因
- 不只显示现象，还建议解决方案
- 每个错误都是一堂mini课程

### 4. 理论与实践结合（Theory Meets Practice）

> **"理论指导实践，实践验证理论。"**

代码直接对应理论课内容：
- 函数名、变量名与课本术语一致
- 代码注释引用理论课概念
- 运行输出印证理论课图示
- 每个实验都能回答"为什么这样设计"

---

## 适合什么人？

### ✅ 适合你，如果：

1. **刚上完操作系统理论课**
   - 知道VPN、PPN、页表等概念
   - 但不知道计算机内部如何执行
   - 想通过实践加深理解

2. **想入门OS开发，但觉得其他教程太难**
   - rCore每章代码太多，不知从何下手
   - xv6全是C语言，调试起来头疼
   - 需要更小步骤、更多指引

3. **喜欢"看得见"的学习方式**
   - 不满足于"黑盒测试"
   - 想知道每一步发生了什么
   - 希望通过可视化理解抽象概念

4. **准备参加OS竞赛或深入学习**
   - 需要快速建立知识体系
   - 想打好基础再挑战rCore/Linux
   - 需要一个"练兵场"来实验想法

### ❌ 可能不适合你，如果：

1. **完全零编程基础**
   - ERROR OS假设你至少会一门编程语言
   - 需要了解基本的数据结构（数组、指针）
   - 建议：先学完《Rust程序设计语言》基础部分

2. **想直接开发生产级OS**
   - ERROR OS定位是教学系统，性能不是首要目标
   - 很多地方为了清晰性牺牲了效率
   - 建议：完成ERROR OS后，继续学习Linux源码

3. **时间非常紧张（少于20小时）**
   - 完整学完ERROR OS需要约40-60小时
   - 如果只是为了应付考试，可能不是最优选择
   - 建议：根据需要选择部分章节学习

---

## 学习路径建议

###  路径1：理论课配套实践（推荐给学生）

```
理论课进度 → ERROR OS实验
─────────────────────────
Week 1-2: 操作系统概述
          → 实验0: 环境搭建与Hello World

Week 3-4: 中断与异常
          → 实验1: 中断处理与时钟中断

Week 5-7: 内存管理
          → 实验2: 物理内存管理
          → 实验3: 虚拟内存（分8步）

Week 8-10: 进程管理
          → 实验4: 进程创建与切换
          → 实验5: 进程调度

Week 11-13: 文件系统
          → 实验6: 简单文件系统
          → 实验7: 文件操作

Week 14-15: 综合实验
          → 实验8: 用户程序与Shell
          → 实验9: 系统调用完善
```

###  路径2：快速入门（2周集训）

```
Day 1-2:  环境搭建 + 虚拟内存
Day 3-4:  系统调用
Day 5-7:  进程管理（基础）
Day 8-10: 文件系统（简化版）
Day 11-12: 用户程序
Day 13-14: 综合测试与完善
```

###  路径3：深度学习（为rCore铺路）

```
Phase 1: ERROR OS 完整学习（4-6周）
         ↓ 理解"为什么"和"怎么做"

Phase 2: rCore-Tutorial（6-8周）
         ↓ 掌握工程实践和代码规范

Phase 3: xv6源码阅读（4周）
         ↓ 学习经典设计与实现

Phase 4: Linux内核模块（进阶）
         ↓ 接触生产级系统
```

---

## 本指导书的结构

```
实验指导书结构：

第一部分：基础篇
├─ 第0章：环境搭建与工具链
├─ 第1章：启动流程与串口输出
├─ 第2章：中断系统
└─ 第3章：物理内存管理

第二部分：核心篇（重点）
├─ 第4章：虚拟内存管理 
│   ├─ 4.1 虚拟地址解析
│   ├─ 4.2 页表遍历
│   ├─ 4.3 页面映射
│   ├─ 4.4 地址空间抽象
│   └─ 4.5 内核地址空间
├─ 第5章：系统调用 
├─ 第6章：进程管理 
│   ├─ 6.1 进程控制块
│   ├─ 6.2 上下文切换
│   ├─ 6.3 进程调度
│   └─ 6.4 进程生命周期
└─ 第7章：文件系统 

第三部分：进阶篇
├─ 第8章：用户程序与ELF加载
├─ 第9章：Shell实现
└─ 第10章：性能优化与调试技巧

附录：
├─ 附录A：RISC-V指令速查
├─ 附录B：常见错误与解决方案
├─ 附录C：从ERROR OS到rCore的迁移指南
└─ 附录D：推荐阅读与学习资源
```

---

## 给学习者的话

操作系统是计算机科学皇冠上的明珠，既优雅又复杂。学习OS不是一蹴而就的过程，需要耐心、细心和恒心。

**ERROR OS 的承诺**：
- 每个步骤都能运行，每个输出都有意义
- 遇到问题时，系统会告诉你为什么、怎么解决
- 学完后，你会理解OS的核心原理，而不只是"敲代码"
- 这是通往rCore、Linux的坚实桥梁

**学习建议**：
1. **不要跳步骤**：每个步骤都有存在的意义，跳过会影响后续理解
2. **多用verbose模式**：看不懂时，打开详细输出，看看内部发生了什么
3. **主动制造错误**：故意写错代码，看看系统如何诊断，理解错误机制
4. **对照理论课**：实验前回顾理论课内容，实验后思考对应关系
5. **记录学习笔记**：写下你的理解和疑问，学习效果会更好

**遇到困难时**：
- 先看ERROR OS的详细输出
- 再查阅本指导书的"常见问题"部分
- 然后尝试使用GDB调试
- 最后求助社区（附有详细的问题描述）

---

## 版本与更新

- **当前版本**：v0.1.0-alpha
- **最后更新**：2025年11月24日
- **支持的架构**：RISC-V 64 (rv64gc)
- **支持的平台**：QEMU virt machine

---

## 致谢

ERROR OS 的开发受到以下项目的启发：
- **rCore-Tutorial**：现代化的Rust教学OS，文档质量业界领先
- **xv6-riscv**：MIT经典教学OS，设计简洁优雅
- **Blog OS (by Philipp Oppermann)**：基础框架的来源，感谢Phil的开创性工作
- **RISC-V社区**：提供优秀的开放ISA和丰富的学习资源

感谢所有为操作系统教学做出贡献的前辈和同行！

---

## 准备好了吗？

让我们开始这场激动人心的旅程！

---

> **"I hear and I forget. I see and I remember. I do and I understand."**
>
> **"我听到就忘记，我看到就记住，我做到就理解。"**
>
> — 中国古语

在ERROR OS中，你不只是"听"和"看"，更重要的是"做"和"理解"。

让我们开始吧！
